<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>tank</title>
        <meta name="description" content="">
        <meta name="format-detection" content="telephone-no">
        <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width, minimal-ui">
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="format-detection" content="telephone=no">
    </head>
    <body>
        <script src="./lib/pixi.min.js"></script>
        <script src="./lib/victor.min.js"></script>
        <script src="./lib/require.js"></script>

        <!-- require modules -->
        <script>
        require.register("./modules/config", function(module, exports, require) {
            var Config =
            {
                world: {
                    map: {
                        w: 4096,
                        h: 4096,
                        color: 0x808080,
                        grid: {
                            size: 128,
                        },
                    },
                    view: {
                        w: 600,
                        h: 800,
                        grid: {
                            size: 32,
                            edge: 1,
                            color: 0xa0a0a0
                        },
                    },
                    walkable: {
                        x: 128,
                        y: 128,
                        w: 3840,
                        h: 3840,
                        color: 0xcdcdcd
                    },
                    unitCollideCheckMS: 500,
                    updateMS: 1000 / 30,
                    externalVelocityDecPerSecond: 100,
                    externalVelocityMax: 1000,
                },
            
                hpbar: {
                    edge: {
                        w: 4,
                        color: 0x555555,
                    },
                    w: 100,
                    h: 20,
                    radius: 10,
                    color: 0x86c680,
                    xOffsetRatio: 0,
                    yOffsetRatio: 1.2,
                    displayRatio: 0.5,
                    alpha: 0.75,
                },
            
                dieAnimation: {
                    alphaStart: 0.4,
                    alphaDecrease: 0.1,
                    alphaEnd: 0.1,
                    scaleIncrease: 0.1
                },
            
                bullets: {
                    normal: {
                        edge: {
                            w: 2,
                            color: 0x555555
                        },
                        body: {
                            radius: 10,
                            color: 0x00b2e1
                        },
                        speed: 300,
                        duration: 1000,
                        hp: 1,
                        damage: 10,
                    }
                },
            
                obstacles: {
                    count: 100,
                    small: {
                        side: 3,
                        radius: 25,
                        color: 0xfc7676,
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        rotationSpeed: 0.5,
                        moveSpeed: 3,
                        hp: 10,
                        damage: 2,
                    },
                    middle: {
                        side: 4,
                        radius: 28,
                        color: 0xffe869,
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        rotationSpeed: 0.5,
                        moveSpeed: 3,
                        hp: 20,
                        damage: 4,
                    },
                    large: {
                        side: 5,
                        radius: 32,
                        color: 0x768dfc,
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        rotationSpeed: 0.5,
                        moveSpeed: 3,
                        hp: 40,
                        damage: 8,
                    },
                },
            
                tanks: {
                    base: {
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        body: {
                            radius: 30,
                            color: 0x00b2e1
                        },
                        weapons: [
                            {
                                w: 15,
                                h: 50,
                                x: 0,
                                y: 0,
                                bullet: "normal",
                                angle: 0,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 3,
                                disturbDeg: 15,
                            },
                        ],
                        speed: 160,
                        hp: 100,
                        damage: 10,
                    },
                    twin: {
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        body: {
                            radius: 30,
                            color: 0x00b2e1
                        },
                        weapons: [
                            {
                                w: 15,
                                h: 50,
                                x: -10,
                                y: 0,
                                bullet: "normal",
                                angle: 0,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 3,
                                disturbDeg: 15,
                            },
                            {
                                w: 15,
                                h: 50,
                                x: 10,
                                y: 0,
                                bullet: "normal",
                                angle: 0,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 6,
                                disturbDeg: 15,
                            }
                        ],
                        speed: 160,
                        hp: 200,
                        damage: 10,
                    },
                    quad: {
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        body: {
                            radius: 30,
                            color: 0x00b2e1
                        },
                        weapons: [
                            {
                                w: 20,
                                h: 45,
                                x: 0,
                                y: 0,
                                bullet: "normal",
                                angle: 0,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 3,
                                disturbDeg: 15,
                            },
                            {
                                w: 20,
                                h: 45,
                                x: 0,
                                y: 0,
                                bullet: "normal",
                                angle: 90,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 3,
                                disturbDeg: 15,
                            },
                            {
                                w: 20,
                                h: 45,
                                x: 0,
                                y: 0,
                                bullet: "normal",
                                angle: 180,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 6,
                                disturbDeg: 15,
                            },
                            {
                                w: 20,
                                h: 45,
                                x: 0,
                                y: 0,
                                bullet: "normal",
                                angle: 270,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 6,
                                disturbDeg: 15,
                            },
                        ],
                        speed: 160,
                        hp: 200,
                        damage: 10,
                    },
                }
            };
            
            module.exports = Config;
        });
        </script>
        <script>
        require.register("./modules/bullet", function(module, exports, require) {
            var Config = require("../modules/config");
            var Motion = require("../modules/motion");
            var Util = require("../modules/util");
            
            function Bullet(world, position, angle, weapon)
            {
                this.id = Util.getId();
                this.type = Util.unitType.bullet;
                this.world = world;
                this.owner = weapon.owner;
                this.bornTime = world.time;
                this.cfg = Config.bullets[weapon.cfg.bullet];
                this.hp = this.cfg.hp;
                this.damage = this.cfg.damage;
                this.motion = new Motion(this, this.cfg.speed);
                this.motion.setMoveDirByAngle(angle);
            
                // view
                var graphics = new PIXI.Graphics();
                graphics.lineStyle(this.cfg.edge.w, this.cfg.edge.color);
                graphics.beginFill(this.cfg.body.color);
                graphics.drawCircle(0, 0, this.cfg.body.radius);
                graphics.endFill();
                delete graphics;
                this.sprite = new PIXI.Sprite(graphics.generateTexture());
                this.sprite.anchor.x = 0.5;
                this.sprite.anchor.y = 0.5;
                world.view.addChild(this.sprite);
            
                this.x = position.x;
                this.y = position.y;
                world.addUnitToGrid(this);
            
                this.radius = this.cfg.body.radius + this.cfg.edge.w;
            }
            
            Bullet.prototype = {}
            
            Bullet.prototype.outOfBounds = function()
            {
                if (this.x <= 0 || this.x >= this.world.w
                    || this.y <= 0 || this.y >= this.world.h) {
                    return true;
                }
                return false;
            }
            
            Bullet.prototype.outOfDate = function()
            {
                if (this.world.time > this.bornTime + this.cfg.duration) {
                    return true;
                }
                return false;
            }
            
            Bullet.prototype.takeDamageByUnit = function(caster)
            {
                this.hp -= caster.damage;
                if (this.hp <= 0) {
                    this.die();
                }
            }
            
            Bullet.prototype.die = function()
            {
                delete this.world.bullets[this.id];
                this.world.dieSprites.push(this.sprite);
                this.world.removeUnitFromGrid(this);
                this.world.removeUnits.push(this);
            }
            
            Bullet.prototype.update = function()
            {
                this.motion.update(Config.world.updateMS);
            }
            
            Object.defineProperties(Bullet.prototype, {
                x: {
                    get: function() { return this.sprite.x; },
                    set: function(v) { this.sprite.x = v; }
                },
                y: {
                    get: function() { return this.sprite.y; },
                    set: function(v) { this.sprite.y = v; }
                },
            });
            
            module.exports = Bullet;
            
        });
        </script>
        <script>
        require.register("./modules/hpbar", function(module, exports, require) {
            var Config = require("../modules/config");
            
            function HpBar(world, cfg, owner, display)
            {
                this.world = world;
                this.cfg = cfg;
                this.owner = owner;
                this.display = display;
                this.percent = 1;
            
                var graphics = new PIXI.Graphics();
                graphics.lineStyle(this.cfg.edge.w, this.cfg.edge.color);
                graphics.beginFill(this.cfg.edge.color);
                graphics.drawRoundedRect(0, 0, this.cfg.w, this.cfg.h, this.cfg.radius);
                graphics.endFill();
                this.backSprite = new PIXI.Sprite(graphics.generateTexture());
                this.backSprite.anchor.x = 0.5;
                this.backSprite.anchor.y = 0.5;
            
                graphics.lineStyle(this.cfg.edge.w, this.cfg.edge.color);
                graphics.beginFill(this.cfg.color);
                graphics.drawRoundedRect(0, 0, this.cfg.w, this.cfg.h, this.cfg.radius);
                graphics.endFill();
                this.frontSprite = new PIXI.Sprite(graphics.generateTexture());
                this.frontSprite.anchor.x = 0.5;
                this.frontSprite.anchor.y = 0.5;
            
                this.sprite = new PIXI.Container();
                this.sprite.addChild(this.backSprite);
                this.sprite.addChild(this.frontSprite);
                this.sprite.alpha = this.cfg.alpha;
            
                var bounds = this.owner.sprite.getLocalBounds();
            
                // long side
                var x1 = bounds.width + bounds.x;
                var x2 = Math.abs(bounds.x);
                if (x1 > x2) {
                    this.x = this.owner.x + x1 * this.cfg.xOffsetRatio;
                } else {
                    this.x = this.owner.x + x2 * this.cfg.xOffsetRatio;
                }
                var y1 = bounds.height + bounds.y;
                var y2 = Math.abs(bounds.y);
                if (y1 > y2) {
                    this.y = this.owner.y + y1 * this.cfg.yOffsetRatio;
                } else {
                    this.y = this.owner.y + y2 * this.cfg.yOffsetRatio;
                }
            
                this.scale.x = this.cfg.displayRatio;
                this.scale.y = this.cfg.displayRatio;
            
                world.view.addChild(this.sprite);
            }
            
            HpBar.prototype = {}
            
            HpBar.prototype.update = function(percent)
            {
                if (this.percent == percent) {
                    return;
                }
            
                this.frontSprite.x += this.cfg.w * (1 - this.percent) / 2;
                this.percent = percent;
                this.frontSprite.width = this.cfg.w * percent;
                this.frontSprite.x -= this.cfg.w * (1 - this.percent) / 2;
            
                // full hp & default not display
                if (Math.abs(percent - 1) < 1e-6 && this.display == false) {
                    this.visible = false;
                }
            }
            
            Object.defineProperties(HpBar.prototype, {
                x: {
                    get: function() { return this.sprite.x; },
                    set: function(v) { this.sprite.x = v; }
                },
                y: {
                    get: function() { return this.sprite.y; },
                    set: function(v) { this.sprite.y = v; }
                },
                scale: {
                    get: function() { return this.sprite.scale; },
                    set: function(s) { this.sprite.scale = s; }
                },
                w: {
                    get: function() { return this.sprite.width; }
                },
                h: {
                    get: function() { return this.sprite.height; }
                },
            });
            
            module.exports = HpBar;
            
        });
        </script>
        <script>
        require.register("./modules/motion", function(module, exports, require) {
            var Config = require("../modules/config");
            var Util = require("../modules/util");
            
            var epsilon = 1e-6;
            
            function Motion(owner, velocity, rotate)
            {
                this.owner = owner;
                this.moveDir = new Victor(0, 0);
                this.velocity = velocity;
                this.rotate = rotate;
                this.iv = new Victor(0, 0); // internal
                this.ev = new Victor(0, 0); // external
            }
            
            Motion.prototype = {}
            
            Motion.prototype.randomMoveDir = function()
            {
                var angle = Math.random() * Math.PI * 2;
                this.moveDir.x = Math.cos(angle);
                this.moveDir.y = Math.sin(angle);
            }
            
            Motion.prototype.setMoveDirByAngle = function(angle)
            {
                this.moveDir.x = Math.cos(angle);
                this.moveDir.y = Math.sin(angle);
            }
            
            Motion.prototype.reverseMoveDirX = function()
            {
                this.moveDir.x = -this.moveDir.x;
            }
            
            Motion.prototype.reverseMoveDirY = function()
            {
                this.moveDir.y = -this.moveDir.y;
            }
            
            Motion.prototype.update = function(deltaMS)
            {
                if (this.moveDir.length() > epsilon) {
                    var angle = this.moveDir.angle();
                    this.iv.x = this.velocity * Math.cos(angle);
                    this.iv.y = this.velocity * Math.sin(angle);
                } else {
                    this.iv.x = 0;
                    this.iv.y = 0;
                }
            
                var elen = this.ev.length();
                if (elen > epsilon) {
                    var dec = Config.world.externalVelocityDecPerSecond * deltaMS / 1000;
                    elen = elen > dec ? (elen - dec) : 0;
                    this.ev.norm().multiply(new Victor(elen, elen));
                }
            
                this.owner.x += (this.iv.x + this.ev.x) * deltaMS / 1000;
                this.owner.y += (this.iv.y + this.ev.y) * deltaMS / 1000;
            
                var cfg = Config.world.map;
                Util.clampPosition(this.owner, 0, cfg.w, 0, cfg.h);
            
                if (this.rotate != null && Math.abs(this.rotate) > epsilon) {
                    this.owner.sprite.rotation += this.rotate * deltaMS / 1000;
                }
            }
            
            Object.defineProperties(Motion.prototype, {
                vx: {
                    get: function() { return this.iv.x + this.ev.x; }
                },
                vy: {
                    get: function() { return this.iv.y + this.ev.y; }
                },
            });
            
            module.exports = Motion;
        });
        </script>
        <script>
        require.register("./modules/obstacle", function(module, exports, require) {
            var Config = require("../modules/config");
            var HpBar = require("../modules/hpbar");
            var Motion = require("../modules/motion");
            var Util = require("../modules/util");
            
            function Obstacle(world, cfg, position)
            {
                this.world = world;
                this.id = Util.getId();
                this.type = Util.unitType.obstacle;
                this.cfg = cfg;
                this.hp = this.cfg.hp;
                this.fullHp = this.cfg.hp;
                this.damage = this.cfg.damage;
            
                // view
                var graphics = new PIXI.Graphics();
                graphics.lineStyle(this.cfg.edge.w, this.cfg.edge.color);
                graphics.beginFill(this.cfg.color);
                var from = new PIXI.Point(0, this.cfg.radius);
                graphics.moveTo(from.x, from.y);
                for (var i = 1; i < this.cfg.side; ++ i) {
                    var p = new Victor(from.x, from.y);
                    p.rotate(Math.PI * 2 / this.cfg.side);
                    graphics.lineTo(p.x, p.y);
                    from.set(p.x, p.y);
                    delete p;
                }
                graphics.endFill();
                delete from;
                delete graphics;
                this.sprite = new PIXI.Sprite(graphics.generateTexture());
                this.sprite.anchor.x = 0.5;
                this.sprite.anchor.y = (this.cfg.radius + this.cfg.edge.w) / this.sprite.height;
                world.view.addChild(this.sprite);
            
                this.x = position.x;
                this.y = position.y;
                world.addUnitToGrid(this);
            
                this.radius = this.cfg.radius + this.cfg.edge.w;
                this.motion = new Motion(this, this.cfg.moveSpeed, this.cfg.rotationSpeed);
                this.motion.randomMoveDir();
                this.hpbar = new HpBar(world, Config.hpbar, this, false);
            }
            
            Obstacle.prototype = {}
            
            Obstacle.prototype.takeDamageByUnit = function(caster)
            {
                this.hp -= caster.damage;
                if (this.hp <= 0) {
                    this.die();
                }
            }
            
            Obstacle.prototype.die = function()
            {
                delete this.world.obstacles[this.id];
                this.world.dieSprites.push(this.sprite);
                this.world.view.removeChild(this.hpbar.sprite);
                this.world.removeUnitFromGrid(this);
                this.world.removeUnits.push(this);
            }
            
            Obstacle.prototype.update = function()
            {
                var oldX = this.x;
                var oldY = this.y;
                this.motion.update(Config.world.updateMS);
            
                this.hpbar.update(this.hp / this.fullHp);
                this.hpbar.x += (this.x - oldX);
                this.hpbar.y += (this.y - oldY);
            
                if (this.x < Config.world.walkable.x
                    || this.x > Config.world.walkable.x + Config.world.walkable.w) {
                    this.motion.reverseMoveDirX();
                }
                if (this.y < Config.world.walkable.y
                    || this.y > Config.world.walkable.y + Config.world.walkable.h) {
                    this.motion.reverseMoveDirY();
                }
            }
            
            Object.defineProperties(Obstacle.prototype, {
                x: {
                    get: function() { return this.sprite.x; },
                    set: function(v) { this.sprite.x = v; }
                },
                y: {
                    get: function() { return this.sprite.y; },
                    set: function(v) { this.sprite.y = v; }
                },
                h: {
                    get: function() { return this.sprite.height; }
                },
                w: {
                    get: function() { return this.sprite.width; }
                },
            });
            
            module.exports = Obstacle;
        });
        </script>
        <script>
        require.register("./modules/player", function(module, exports, require) {
            function Player(world, tank)
            {
                this.world = world;
                this.tank = tank;
                // TODO: client info
            }
            
            Player.prototype = {}
            
            function handleKeyDown(player)
            {
                document.body.addEventListener('keydown', function(e) {
                    if (player.tank == null) {
                        return;
                    }
                    switch (e.key) {
                        case 'w':
                        case 'W':
                            player.tank.motion.moveDir.y -= 1;
                            if (player.tank.motion.moveDir.y < -1) {
                                player.tank.motion.moveDir.y = -1;
                            }
                            break;
                        case 'd':
                        case 'D':
                            player.tank.motion.moveDir.x += 1;
                            if (player.tank.motion.moveDir.x > 1) {
                                player.tank.motion.moveDir.x = 1;
                            }
                            break;
                        case 's':
                        case 'S':
                            player.tank.motion.moveDir.y += 1;
                            if (player.tank.motion.moveDir.y > 1) {
                                player.tank.motion.moveDir.y = 1;
                            }
                            break;
                        case 'a':
                        case 'A':
                            player.tank.motion.moveDir.x -= 1;
                            if (player.tank.motion.moveDir.x < -1) {
                                player.tank.motion.moveDir.x = -1;
                            }
                            break;
                    }
                }, false);
            }
            
            function handleKeyUp(player)
            {
                document.body.addEventListener('keyup', function(e) {
                    if (player.tank == null) {
                        return;
                    }
                    switch (e.key) {
                        case 'w':
                        case 'W':
                            player.tank.motion.moveDir.y += 1;
                            if (player.tank.motion.moveDir.y > 1) {
                                player.tank.motion.moveDir.y = 1;
                            }
                            break;
                        case 'd':
                        case 'D':
                            player.tank.motion.moveDir.x -= 1;
                            if (player.tank.motion.moveDir.x < -1) {
                                player.tank.motion.moveDir.x = -1;
                            }
                            break;
                        case 's':
                        case 'S':
                            player.tank.motion.moveDir.y -= 1;
                            if (player.tank.motion.moveDir.y < -1) {
                                player.tank.motion.moveDir.y = -1;
                            }
                            break;
                        case 'a':
                        case 'A':
                            player.tank.motion.moveDir.x += 1;
                            if (player.tank.motion.moveDir.x > 1) {
                                player.tank.motion.moveDir.x = 1;
                            }
                            break;
                    }
                }, false);
            }
            
            function handleMouseMove(player)
            {
                document.body.addEventListener('mousemove', function(e) {
                    var targetPos = new Victor(e.x - player.world.view.x, e.y - player.world.view.y);
                    if (player.tank != null) {
                        // TODO: rotate speed
                        var dir = targetPos.subtract(new Victor(player.tank.x, player.tank.y));
                        player.tank.rotation = dir.angle() + Math.PI / 2;
                    }
                }, false);
            }
            
            function handleMouseDown(player) {
                document.body.addEventListener('mousedown', function(e) {
                    if (player.tank != null) {
                        player.tank.fire();
                    }
                }, false);
            }
            
            Player.prototype.addControl = function()
            {
                if (this.tank) {
                    handleKeyDown(this);
                    handleKeyUp(this);
                    handleMouseMove(this);
                    handleMouseDown(this);
                }
            }
            
            Player.prototype.update = function()
            {
            }
            
            Object.defineProperties(Player.prototype, {
                x: {
                    get: function() { return this.tank.x; }
                },
                y: {
                    get: function() { return this.tank.y; }
                },
            });
            
            module.exports = Player;
            
        });
        </script>
        <script>
        require.register("./modules/tank", function(module, exports, require) {
            var Config = require("../modules/config");
            var HpBar = require("../modules/hpbar");
            var Motion = require("../modules/motion");
            var Weapon = require("../modules/weapon");
            var Util = require("../modules/util");
            
            function Tank(world, name, position)
            {
                this.world = world;
                this.id = Util.getId();
                this.type = Util.unitType.tank;
                this.cfg = Config.tanks[name];
                this.hp = this.cfg.hp;
                this.fullHp = this.cfg.hp;
                this.damage = this.cfg.damage;
                // this.autoFire = true;
            
                // view & weapons
                this.sprite = new PIXI.Container();
                this.weapons = [];
                for (var idx in this.cfg.weapons) {
                    var weapon = new Weapon(world, this, this.cfg.weapons[idx]);
                    this.weapons.push(weapon);
                    this.sprite.addChild(weapon.sprite);
                }
                var graphics = new PIXI.Graphics();
                graphics.lineStyle(this.cfg.edge.w, this.cfg.edge.color);
                graphics.beginFill(this.cfg.body.color);
                graphics.drawCircle(0, 0, this.cfg.body.radius);
                graphics.endFill();
                var bodySprite = new PIXI.Sprite(graphics.generateTexture());
                graphics.destroy();
                bodySprite.anchor.x = 0.5;
                bodySprite.anchor.y = 0.5;
                this.sprite.addChild(bodySprite);
                world.view.addChild(this.sprite);
            
                this.x = position.x;
                this.y = position.y;
                world.addUnitToGrid(this);
            
                this.radius = this.cfg.body.radius + this.cfg.edge.w;
                this.motion = new Motion(this, this.cfg.speed);
                this.hpbar = new HpBar(world, Config.hpbar, this, true);
            }
            
            Tank.prototype = {}
            
            Tank.prototype.takeDamageByUnit = function(caster)
            {
                this.hp -= caster.damage;
                if (this.hp <= 0) {
                    this.die();
                }
            }
            
            Tank.prototype.die = function()
            {
                delete this.world.tanks[this.id];
                this.world.dieSprites.push(this.sprite);
                this.world.removeUnitFromGrid(this);
                this.world.removeUnits.push(this);
            
                // TODO:
                if (this.world.player == this) {
                    alert("player die");
                }
            }
            
            Tank.prototype.update = function()
            {
                var oldX = this.x;
                var oldY = this.y;
                this.motion.update(Config.world.updateMS);
            
                this.hpbar.update(this.hp / this.fullHp);
                this.hpbar.x += (this.x - oldX);
                this.hpbar.y += (this.y - oldY);
            
                if (this.autoFire == true) {
                    this.fire();
                }
            }
            
            Tank.prototype.fire = function()
            {
                for (var idx in this.weapons) {
                    this.weapons[idx].fire();
                }
            }
            
            Object.defineProperties(Tank.prototype, {
                x: {
                    get: function() { return this.sprite.x; },
                    set: function(v) { this.sprite.x = v; }
                },
                y: {
                    get: function() { return this.sprite.y; },
                    set: function(v) { this.sprite.y = v; }
                },
                h: {
                    get: function() { return this.sprite.height; }
                },
                w: {
                    get: function() { return this.sprite.width; }
                },
                rotation: {
                    get: function() { return this.sprite.rotation; },
                    set: function(r) { this.sprite.rotation = r; }
                },
            });
            
            module.exports = Tank;
            
        });
        </script>
        <script>
        require.register("./modules/weapon", function(module, exports, require) {
            var Bullet = require("../modules/bullet");
            var Util = require("../modules/util");
            
            function weaponCreateView(weapon)
            {
            }
            
            function Weapon(world, tank, cfg)
            {
                this.world = world;
                this.id = Util.getId();
                this.type = Util.unitType.weapon;
                this.owner = tank;
                this.cfg = cfg;
                this.angle = this.cfg.angle;
                this.offset = new Victor(0, - this.cfg.shootOffset - this.cfg.h);
                this.offset.rotateDeg(this.cfg.angle)
                           .add(new Victor(this.cfg.x, this.cfg.y));
                this.fireFrame = world.frame + this.cfg.shootDelayFrame;
            
                // view
                var graphics = new PIXI.Graphics();
                graphics.lineStyle(this.owner.cfg.edge.w, this.owner.cfg.edge.color);
                graphics.beginFill(this.cfg.color);
                graphics.drawRect(0, 0, this.cfg.w, this.cfg.h);
                graphics.endFill();
                this.sprite = new PIXI.Sprite(graphics.generateTexture());
                graphics.destroy();
                this.sprite.anchor.x = 0.5;
                this.sprite.anchor.y = 1.0;
                this.sprite.rotation = this.cfg.angle * Math.PI / 180;
                this.sprite.x += this.cfg.x;
                this.sprite.y += this.cfg.y;
            }
            
            Weapon.prototype = {}
            
            Weapon.prototype.fire = function()
            {
                if (this.world.frame - this.fireFrame >= this.cfg.reloadFrame) {
            
                    this.fireFrame = this.world.frame;
            
                    var pos = this.offset.clone();
                    pos.rotate(this.owner.rotation);
                    pos.add(new Victor(this.owner.sprite.position.x, this.owner.sprite.position.y));
                    if (pos.x <= 0 || pos.y <= 0 || pos.x >= this.world.w || pos.y >= this.world.h) {
                        return;
                    }
            
                    var angle = this.owner.rotation + this.cfg.angle * Math.PI / 180 - Math.PI / 2;
                    var disturb = this.cfg.disturbDeg * Math.PI / 180;
                    angle += (Math.random() * disturb - disturb / 2);
            
                    var bullet = new Bullet(this.world, pos, angle, this);
                    this.world.bullets[bullet.id] = bullet;
                }
            }
            
            module.exports = Weapon;
            
        });
        </script>
        <script>
        require.register("./modules/world", function(module, exports, require) {
            var Config = require("../modules/config");
            var Obstacle = require("../modules/obstacle");
            var Player = require("../modules/player")
            var Tank = require("../modules/tank");
            var Util = require("../modules/util");
            
            function getWorldBackground()
            {
                var cfg = Config.world;
                var graphics = new PIXI.Graphics();
            
                // background walkable region
                graphics.beginFill(cfg.walkable.color);
                graphics.drawRect(cfg.walkable.x, cfg.walkable.y,
                    cfg.walkable.w, cfg.walkable.h);
                graphics.endFill();
            
                // background grids
                graphics.lineStyle(cfg.view.grid.edge, cfg.view.grid.color);
                for (var x = cfg.view.grid.size; x < cfg.map.w; x += cfg.view.grid.size) {
                    graphics.moveTo(x, 0);
                    graphics.lineTo(x, cfg.map.h);
                }
                for (var y = cfg.view.grid.size; y < cfg.map.h; y += cfg.view.grid.size) {
                    graphics.moveTo(0, y);
                    graphics.lineTo(cfg.map.w, y);
                }
            
                return graphics;
            }
            
            function World()
            {
                this.frame = 0;
            
                this.w = Config.world.map.w;
                this.h = Config.world.map.h;
            
                this.gridSize = Config.world.map.grid.size;
                this.gridW = Math.floor(this.w / this.gridSize) + 1;
                this.gridH = Math.floor(this.h / this.gridSize) + 1;
                this.grids = [];
                for (var i = 0; i < this.gridH; ++ i) {
                    for (var j = 0; j < this.gridW; ++ j) {
                        this.grids.push({});
                    }
                }
            
                var dateTime = new Date();
                this.time = dateTime.getTime();
            
                this.stage = new PIXI.Container();
            
                // main view (camera bind)
                this.view = new PIXI.Container();
                this.view.addChild(getWorldBackground());
                this.stage.addChild(this.view);
            
                // UI & HUD
                this.ui = new PIXI.Container();
                this.stage.addChild(this.ui);
            
                this.renderer = new PIXI.CanvasRenderer(Config.world.view.w, Config.world.view.h, {
                        backgroundColor: Config.world.map.color,
                        antialias: true,
                        autoResize: true,
                    });
                document.body.appendChild(this.renderer.view);
            
                // world objects
                this.bullets = {};
                this.obstacles = [];
                this.obstacleCount = 0;
                this.tanks = [];
                var idx = 0;
                for (var i in Config.tanks) {
                    var tank = new Tank(this, i, { x: this.w / 2 + idx * 200, y: this.h / 2 + idx * 200, });
                    this.tanks.push(tank);
                    ++ idx;
                }
            
                // player
                this.player = new Player(this, this.tanks[0]);
                this.player.addControl();
            
                // die sprites
                this.dieSprites = [];
                this.removeUnits = [];
            }
            
            World.prototype = {};
            World.prototype.constructor = World;
            
            World.prototype.updateCamera = function()
            {
                var x = this.player.x;
                var y = this.player.y;
                var viewCenterX = Config.world.view.w / 2;
                var viewCenterY = Config.world.view.h / 2;
                x = Util.clamp(x, viewCenterX, this.w - viewCenterX);
                y = Util.clamp(y, viewCenterY, this.h - viewCenterY);
                this.view.x = viewCenterX - x;
                this.view.y = viewCenterY - y;
            }
            
            World.prototype.updateTanks = function()
            {
                for (var i in this.tanks) {
                    var tank = this.tanks[i];
                    var oldx = tank.x;
                    var oldy = tank.y;
                    tank.update();
                    this.updateUnitGrid(tank, { x: oldx, y: oldy });
                }
            }
            
            World.prototype.updatePlayers = function()
            {
                this.player.update();
            }
            
            World.prototype.updateObstacles = function()
            {
                if (this.obstacleCount < Config.obstacles.count) {
                    var cfgs = [
                        Config.obstacles.small,
                        Config.obstacles.middle,
                        Config.obstacles.large
                    ];
                    var cfg = cfgs[Math.floor((Math.random() * cfgs.length))];
                    var wcfg = Config.world.walkable;
                    var obstacle = new Obstacle(this, cfg, {
                        x: Util.randomBetween(wcfg.x, wcfg.x + wcfg.w),
                        y: Util.randomBetween(wcfg.y, wcfg.y + wcfg.h),
                    });
                    this.obstacles[obstacle.id] = obstacle;
                    this.obstacleCount ++;
                }
            
                for (var i in this.obstacles) {
                    var obstacle = this.obstacles[i];
                    var oldx = obstacle.x;
                    var oldy = obstacle.y;
                    obstacle.update();
                    this.updateUnitGrid(obstacle, { x: oldx, y: oldy });
                }
            }
            
            World.prototype.updateBullets = function()
            {
                for (var i in this.bullets) {
                    var bullet = this.bullets[i];
                    if (bullet.outOfDate() || bullet.outOfBounds()) {
                        bullet.die();
                    } else {
                        var oldx = bullet.x;
                        var oldy = bullet.y;
                        bullet.update();
                        this.updateUnitGrid(bullet, { x: oldx, y: oldy });
                    }
                }
            }
            
            World.prototype.getUnitsIn9Grids = function(x, y)
            {
                var targets = [];
                var idxs = [
                    (y - 1) * this.gridW + x - 1,
                    (y - 1) * this.gridW + x,
                    (y - 1) * this.gridW + x + 1,
                    y * this.gridW + x - 1,
                    y * this.gridW + x,
                    y * this.gridW + x + 1,
                    (y + 1) * this.gridW + x - 1,
                    (y + 1) * this.gridW + x,
                    (y + 1) * this.gridW + x + 1,
                ];
            
                var x1 = (x >= 1);
                var x2 = (x < this.gridW - 1);
            
                var y1 = (y >= 1);
                var y2 = (y < this.gridH - 1);
            
                if (y1 && x1) {
                    var g = this.grids[idxs[0]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (y1) {
                    var g = this.grids[idxs[1]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (y1 && x2) {
                    var g = this.grids[idxs[2]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (x1) {
                    var g = this.grids[idxs[3]];
                    for (var i in g) { targets.push(g[i]); }
                }
                {
                    var g = this.grids[idxs[4]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (x2) {
                    var g = this.grids[idxs[5]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (y2 && x1) {
                    var g = this.grids[idxs[6]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (y2) {
                    var g = this.grids[idxs[7]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (y2 && x2) {
                    var g = this.grids[idxs[8]];
                    for (var i in g) { targets.push(g[i]); }
                }
                return targets;
            }
            
            World.prototype.needCheckCollision = function(unit, target)
            {
                var u1 = (unit.owner == null ? unit : unit.owner);
                var u2 = (target.owner == null ? target : target.owner);
                return u1 != u2;
            }
            
            World.prototype.collide = function(unit1, unit2)
            {
                // Elastic collision
                // m1, v10
                // m2, v20
                // v1 = [(m1-m2)v10 + 2m2v20] / (m1+m2)
                // v2 = [(m2-m1)v20 + 2m1v10] / (m1+m2)
            
                // console.log("frame[" + this.frame + "]");
                // console.log("unit1: ev{" + unit1.motion.ev.x + "," + unit1.motion.ev.y + "}");
                // console.log("unit1: iv{" + unit1.motion.iv.x + "," + unit1.motion.iv.y + "}");
                // console.log("unit2: ev{" + unit2.motion.ev.x + "," + unit2.motion.ev.y + "}");
                // console.log("unit2: iv{" + unit2.motion.iv.x + "," + unit2.motion.iv.y + "}");
            
                var m1 = unit1.radius * unit1.radius;
                var m2 = unit2.radius * unit2.radius;
                var v10 = new Victor(unit1.motion.vx, unit1.motion.vy);
                var v20 = new Victor(unit2.motion.vx, unit2.motion.vy);
            
                var v1x = ((m1 - m2) * v10.x + 2 * m2 * v20.x) / (m1 + m2);
                var v1y = ((m1 - m2) * v10.y + 2 * m2 * v20.y) / (m1 + m2);
                unit1.motion.ev.x += v1x;
                unit1.motion.ev.y += v1y;
            
                var v2x = ((m2 - m1) * v20.x + 2 * m1 * v10.x) / (m1 + m2);
                var v2y = ((m2 - m1) * v20.y + 2 * m1 * v10.y) / (m1 + m2);
                unit2.motion.ev.x += v2x;
                unit2.motion.ev.y += v2y;
            
                // console.log("unit1: ev{" + unit1.motion.ev.x + "," + unit1.motion.ev.y + "}");
                // console.log("unit1: iv{" + unit1.motion.iv.x + "," + unit1.motion.iv.y + "}");
                // console.log("unit2: ev{" + unit2.motion.ev.x + "," + unit2.motion.ev.y + "}");
                // console.log("unit2: iv{" + unit2.motion.iv.x + "," + unit2.motion.iv.y + "}");
            
                // damage each other
                unit1.takeDamageByUnit(unit2);
                unit2.takeDamageByUnit(unit1);
            }
            
            World.prototype.updateCollision = function()
            {
                for (var x = 0; x < this.gridW; ++ x) {
                    for (var y = 0; y < this.gridH; ++ y) {
            
                        var idx = y * this.gridW + x;
                        for (var i in this.grids[idx]) {
                            var unit = this.grids[idx][i];
            
                            // avoid multi-collision
                            if (unit.collideTime != null) {
                                if (this.time - unit.collideTime < Config.world.unitCollideCheckMS) {
                                    continue;
                                }
                            }
            
                            // check collision with targets
                            var targets = this.getUnitsIn9Grids(x, y);
                            for (var j in targets) {
                                var target = targets[j];
                                if (unit == target) {
                                    continue;
                                }
                                if (this.needCheckCollision(unit, target) == false) {
                                    continue;
                                }
                                if (target.collideCheckFrame == this.frame) {
                                    continue;
                                }
                                var distX = unit.x - target.x;
                                var distY = unit.y - target.y;
                                var distR = unit.radius + target.radius;
                                if (distX * distX + distY * distY < distR * distR) {
                                    unit.collideTime = this.time;
                                    target.collideTime = this.time;
                                    this.collide(unit, target);
                                    // console.log("frame=" + this.frame + " collision: " + unit.id + "--" + target.id);
                                }
                            }
                            unit.collideCheckFrame = this.frame;
                        }
                    }
                }
            }
            
            World.prototype.updateDieAnimations = function()
            {
                var cfg = Config.dieAnimation;
                for (var i in this.dieSprites) {
                    var sprite = this.dieSprites[i];
                    if (sprite.alpha > cfg.alphaStart) {
                        sprite.alpha = cfg.alphaStart;
                    } else {
                        sprite.alpha -= cfg.alphaDecrease;;
                    }
                    sprite.scale.x += cfg.scaleIncrease;
                    sprite.scale.y += cfg.scaleIncrease;
                    if (sprite.alpha < cfg.alphaEnd) {
                        var idx = this.view.getChildIndex(sprite);
                        this.view.removeChildAt(idx);
                        this.dieSprites.splice(i, 1);
                        delete sprite;
                    }
                }
            }
            
            World.prototype.updateLogic = function()
            {
                var dateTime = new Date();
                var ms = dateTime.getTime();
                while (ms > this.time + Config.world.updateMS) {
                    this.time += Config.world.updateMS;
                    this.frame ++;
                    this.updateTanks();
                    this.updatePlayers();
                    this.updateObstacles();
                    this.updateBullets();
                    this.updateCollision();
                    this.updateDieAnimations();
                }
            }
            
            World.prototype.updateUnitGrid = function(unit, oldPos)
            {
                if (oldPos.x == unit.x && oldPos.y == unit.y) {
                    return;
                }
            
                var ogx = Math.floor(oldPos.x / this.gridSize);
                var ogy = Math.floor(oldPos.y / this.gridSize);
                var oidx = ogy * this.gridW + ogx;
            
                var gx = Math.floor(unit.x / this.gridSize);
                var gy = Math.floor(unit.y / this.gridSize);
                var idx = gy * this.gridW + gx;
            
                if (idx != oidx) {
                    delete this.grids[oidx][unit.id];
                }
                this.grids[idx][unit.id] = unit;
            }
            
            World.prototype.removeUnitFromGrid = function(unit)
            {
                var gx = Math.floor(unit.x / this.gridSize);
                var gy = Math.floor(unit.y / this.gridSize);
                var idx = gy * this.gridW + gx;
                delete this.grids[idx][unit.id];
            }
            
            World.prototype.addUnitToGrid = function(unit)
            {
                var gx = Math.floor(unit.x / this.gridSize);
                var gy = Math.floor(unit.y / this.gridSize);
                var idx = gy * this.gridW + gx;
                this.grids[idx][unit.id] = unit;
            }
            
            World.prototype.update = function()
            {
                this.updateLogic();
                this.updateCamera();
                this.renderer.render(this.stage);
            }
            
            module.exports = World;
            
        });
        </script>
        <script>
        require.register("./modules/util", function(module, exports, require) {
            var Util = {
            
                id: 0,
            
                unitType: {
                    tank: 1,
                    weapon: 2,
                    bullet: 3,
                    obstacle: 4
                },
            
                clamp: function(value, min, max) {
                    if (value > max) {
                        value = max;
                    }
                    if (value < min) {
                        value = min;
                    }
                    return value;
                },
            
                clampPosition: function(pos, minx, maxx, miny, maxy) {
                    if (pos.x > maxx) {
                        pos.x = maxx;
                    }
                    if (pos.x < minx) {
                        pos.x = minx;
                    }
                    if (pos.y > maxy) {
                        pos.y = maxy;
                    }
                    if (pos.y < miny) {
                        pos.y = miny;
                    }
                },
            
                randomBetween: function(min, max) {
                    return Math.random() * (max - min) + min;
                },
            
                getId: function() {
                    return ++ this.id;
                },
            };
            
            module.exports = Util;
        });
        </script>

        <script src="./main.js"></script>
    </body>
</html>
