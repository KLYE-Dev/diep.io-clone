<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>tank</title>
        <meta name="description" content="">
        <meta name="format-detection" content="telephone-no">
        <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width, minimal-ui">
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="format-detection" content="telephone=no">
    </head>
    <body>
        <script src="./lib/pixi.min.js"></script>
        <script src="./lib/victor.min.js"></script>
        <script src="./lib/require.js"></script>

        <!-- require modules -->
        <script>
        require.register("./modules/config", function(module, exports, require) {
            var Config =
            {
                world: {
                    map: {
                        w: 4096,
                        h: 4096,
                        color: 0x808080,
                        grid: {
                            size: 128,
                        },
                    },
                    view: {
                        w: 600,
                        h: 800,
                        grid: {
                            size: 32,
                            edge: 1,
                            color: 0xa0a0a0
                        },
                    },
                    walkable: {
                        x: 128,
                        y: 128,
                        w: 3840,
                        h: 3840,
                        color: 0xcdcdcd
                    },
                    updateMS: 1000 / 30
                },
            
                hpbar: {
                    edge: {
                        w: 4,
                        color: 0x555555,
                    },
                    w: 100,
                    h: 20,
                    radius: 10,
                    color: 0x86c680,
                    xOffset: 0,
                    yOffset: 35,
                    xDisplayRatio: 1,
                    yDisplayRatio: 0.8,
                    alpha: 0.75,
                },
            
                dieAnimation: {
                    alphaStart: 0.4,
                    alphaDecrease: 0.1,
                    alphaEnd: 0.1,
                    scaleIncrease: 0.1
                },
            
                bullets: {
                    normal: {
                        edge: {
                            w: 2,
                            color: 0x555555
                        },
                        body: {
                            radius: 10,
                            color: 0x00b2e1
                        },
                        speed: 400,
                        duration: 1000
                    }
                },
            
                obstacles: {
                    count: 100,
                    small: {
                        side: 3,
                        radius: 25,
                        color: 0xfc7676,
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        rotationSpeed: 0.5,
                        moveSpeed: 3,
                    },
                    middle: {
                        side: 4,
                        radius: 30,
                        color: 0xffe869,
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        rotationSpeed: 0.5,
                        moveSpeed: 3,
                    },
                    large: {
                        side: 5,
                        radius: 35,
                        color: 0x768dfc,
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        rotationSpeed: 0.5,
                        moveSpeed: 3,
                    },
                },
            
                tanks: {
                    normal: {
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        body: {
                            radius: 30,
                            color: 0x00b2e1
                        },
                        weapons: [
                            {
                                w: 15,
                                h: 50,
                                x: -10,
                                y: 0,
                                bullet: "normal",
                                angle: 0,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 3,
                                disturbDeg: 15,
                            },
                            {
                                w: 15,
                                h: 50,
                                x: 10,
                                y: 0,
                                bullet: "normal",
                                angle: 0,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 6,
                                disturbDeg: 15,
                            }
                        ],
                        speed: 160,
                    }
                }
            };
            
            module.exports = Config;
        });
        </script>
        <script>
        require.register("./modules/bullet", function(module, exports, require) {
            var Config = require("../modules/config");
            var Util = require("../modules/util");
            
            function Bullet(world, position, angle, weapon)
            {
                this.id = Util.getId();
                this.world = world;
                this.owner = weapon.owner;
                this.angle = angle;
                this.bornTime = world.time;
            
                this.cfg = Config.bullets[weapon.cfg.bullet];
                this.speed = this.cfg.speed;
            
                var graphics = new PIXI.Graphics();
                graphics.lineStyle(this.cfg.edge.w, this.cfg.edge.color);
                graphics.beginFill(this.cfg.body.color);
                graphics.drawCircle(0, 0, this.cfg.body.radius);
                graphics.endFill();
                this.sprite = new PIXI.Sprite(graphics.generateTexture());
                delete graphics;
            
                this.sprite.anchor.x = 0.5;
                this.sprite.anchor.y = 0.5;
                world.view.addChild(this.sprite);
            
                this.x = position.x;
                this.y = position.y;
                this.radius = this.cfg.body.radius + this.cfg.edge.w;
            }
            
            Bullet.prototype = {}
            
            Bullet.prototype.outOfBounds = function()
            {
                if (this.x <= 0 || this.x >= this.world.w
                    || this.y <= 0 || this.y >= this.world.h) {
                    return true;
                }
                return false;
            }
            
            Bullet.prototype.outOfDate = function()
            {
                if (this.world.time > this.bornTime + this.cfg.duration) {
                    return true;
                }
                return false;
            }
            
            Bullet.prototype.die = function()
            {
                delete this.world.bullets[this.id];
                this.world.dieSprites.push(this.sprite);
                this.world.removeUnitFromGrid(this);
            }
            
            Bullet.prototype.update = function()
            {
                var oldx = this.x;
                var oldy = this.y;
                this.x += this.speed * Math.cos(this.angle) * Config.world.updateMS / 1000;
                this.y += this.speed * Math.sin(this.angle) * Config.world.updateMS / 1000;
                var cfg = Config.world.map;
                Util.clampPosition(this, 0, cfg.w, 0, cfg.h);
                return 0;
            }
            
            Object.defineProperties(Bullet.prototype, {
                x: {
                    get: function() { return this.sprite.x; },
                    set: function(v) { this.sprite.x = v; }
                },
                y: {
                    get: function() { return this.sprite.y; },
                    set: function(v) { this.sprite.y = v; }
                },
            });
            
            module.exports = Bullet;
            
        });
        </script>
        <script>
        require.register("./modules/hpbar", function(module, exports, require) {
            var Config = require("../modules/config");
            
            function HpBar(world, cfg, owner, display)
            {
                this.world = world;
                this.cfg = cfg;
                this.owner = owner;
                this.display = display;
                this.percent = 1;
            
                var graphics = new PIXI.Graphics();
                graphics.lineStyle(this.cfg.edge.w, this.cfg.edge.color);
                graphics.beginFill(this.cfg.edge.color);
                graphics.drawRoundedRect(0, 0, this.cfg.w, this.cfg.h, this.cfg.radius);
                graphics.endFill();
                this.backSprite = new PIXI.Sprite(graphics.generateTexture());
                this.backSprite.anchor.x = 0.5;
                this.backSprite.anchor.y = 0.5;
            
                graphics.lineStyle(this.cfg.edge.w, this.cfg.edge.color);
                graphics.beginFill(this.cfg.color);
                graphics.drawRoundedRect(0, 0, this.cfg.w, this.cfg.h, this.cfg.radius);
                graphics.endFill();
                this.frontSprite = new PIXI.Sprite(graphics.generateTexture());
                this.frontSprite.anchor.x = 0.5;
                this.frontSprite.anchor.y = 0.5;
            
                this.sprite = new PIXI.Container();
                this.sprite.addChild(this.backSprite);
                this.sprite.addChild(this.frontSprite);
                this.sprite.alpha = this.cfg.alpha;
            
                this.x = this.owner.x + this.cfg.xOffset;
                var bounds = this.owner.sprite.getLocalBounds();
                this.y = this.owner.y + (bounds.height + bounds.y) + this.cfg.yOffset;
            
                var scale = this.owner.w / this.w;
                this.scale.x = this.cfg.xDisplayRatio * scale;
                this.scale.y = this.cfg.yDisplayRatio * scale;
            
                world.view.addChild(this.sprite);
            }
            
            HpBar.prototype = {}
            
            HpBar.prototype.update = function(percent)
            {
                this.percent = percent;
                this.frontSprite.width = this.cfg.w * percent;
                this.frontSprite.x -= this.frontSprite.width * (1 - percent);
            
                // full hp & default not display
                if (Math.abs(percent - 1) < 1e-6 && this.display == false) {
                    this.visible = false;
                }
            }
            
            Object.defineProperties(HpBar.prototype, {
                x: {
                    get: function() { return this.sprite.x; },
                    set: function(v) { this.sprite.x = v; }
                },
                y: {
                    get: function() { return this.sprite.y; },
                    set: function(v) { this.sprite.y = v; }
                },
                scale: {
                    get: function() { return this.sprite.scale; },
                    set: function(s) { this.sprite.scale = s; }
                },
                w: {
                    get: function() { return this.sprite.width; }
                },
                h: {
                    get: function() { return this.sprite.height; }
                },
            });
            
            module.exports = HpBar;
            
        });
        </script>
        <script>
        require.register("./modules/obstacle", function(module, exports, require) {
            var Config = require("../modules/config");
            var Util = require("../modules/util");
            
            function Obstacle(world, cfg, position)
            {
                this.world = world;
                this.cfg = cfg;
                this.id = Util.getId();
            
                var graphics = new PIXI.Graphics();
                graphics.lineStyle(this.cfg.edge.w, this.cfg.edge.color);
                graphics.beginFill(this.cfg.color);
            
                var from = new PIXI.Point(0, this.cfg.radius);
                graphics.moveTo(from.x, from.y);
                for (var i = 1; i < this.cfg.side; ++ i) {
                    var p = new Victor(from.x, from.y);
                    p.rotate(Math.PI * 2 / this.cfg.side);
                    graphics.lineTo(p.x, p.y);
                    from.set(p.x, p.y);
                    delete p;
                }
                graphics.endFill();
                this.sprite = new PIXI.Sprite(graphics.generateTexture());
                delete from;
                delete graphics;
            
                this.sprite.anchor.x = 0.5;
                this.sprite.anchor.y = (this.cfg.radius + this.cfg.edge.w) / this.sprite.height;
                world.view.addChild(this.sprite);
            
                this.x = position.x;
                this.y = position.y;
                this.radius = this.cfg.radius + this.cfg.edge.w;
            
                var angle = Math.random() * Math.PI * 2;
                this.speed = new Victor(this.cfg.moveSpeed * Math.cos(angle),
                    this.cfg.moveSpeed * Math.sin(angle));
            }
            
            Obstacle.prototype = {}
            
            Obstacle.prototype.update = function()
            {
                if (this.x < Config.world.walkable.x) {
                    this.speed.x = - this.speed.x;
                }
                if (this.x > Config.world.walkable.x + Config.world.walkable.w) {
                    this.speed.x = - this.speed.x;
                }
                if (this.y < Config.world.walkable.y) {
                    this.speed.y = - this.speed.y;
                }
                if (this.y > Config.world.walkable.y + Config.world.walkable.h) {
                    this.speed.y = - this.speed.y;
                }
            
                // slow move
                this.x += this.speed.x * Config.world.updateMS / 1000;
                this.y += this.speed.y * Config.world.updateMS / 1000;
                var cfg = Config.world.map;
                Util.clampPosition(this, 0, cfg.w, 0, cfg.h);
            
                // slow rotation
                this.sprite.rotation += this.cfg.rotationSpeed * Config.world.updateMS / 1000;
            }
            
            Object.defineProperties(Obstacle.prototype, {
                x: {
                    get: function() { return this.sprite.x; },
                    set: function(v) { this.sprite.x = v; }
                },
                y: {
                    get: function() { return this.sprite.y; },
                    set: function(v) { this.sprite.y = v; }
                },
                h: {
                    get: function() { return this.sprite.height; }
                },
                w: {
                    get: function() { return this.sprite.width; }
                },
            });
            
            module.exports = Obstacle;
        });
        </script>
        <script>
        require.register("./modules/tank", function(module, exports, require) {
            var Config = require("../modules/config");
            var HpBar = require("../modules/hpbar");
            var Weapon = require("../modules/weapon");
            var Util = require("../modules/util");
            
            function tankHandleKeyDown(tank)
            {
                document.body.addEventListener('keydown', function(e) {
                    switch (e.key) {
                        case 'w':
                        case 'W':
                            tank.moveDir.y -= 1;
                            if (tank.moveDir.y < -1) {
                                tank.moveDir.y = -1;
                            }
                            break;
                        case 'd':
                        case 'D':
                            tank.moveDir.x += 1;
                            if (tank.moveDir.x > 1) {
                                tank.moveDir.x = 1;
                            }
                            break;
                        case 's':
                        case 'S':
                            tank.moveDir.y += 1;
                            if (tank.moveDir.y > 1) {
                                tank.moveDir.y = 1;
                            }
                            break;
                        case 'a':
                        case 'A':
                            tank.moveDir.x -= 1;
                            if (tank.moveDir.x < -1) {
                                tank.moveDir.x = -1;
                            }
                            break;
                    }
                }, false);
            }
            
            function tankHandleKeyUp(tank)
            {
                document.body.addEventListener('keyup', function(e) {
                    switch (e.key) {
                        case 'w':
                        case 'W':
                            tank.moveDir.y += 1;
                            if (tank.moveDir.y > 1) {
                                tank.moveDir.y = 1;
                            }
                            break;
                        case 'd':
                        case 'D':
                            tank.moveDir.x -= 1;
                            if (tank.moveDir.x < -1) {
                                tank.moveDir.x = -1;
                            }
                            break;
                        case 's':
                        case 'S':
                            tank.moveDir.y -= 1;
                            if (tank.moveDir.y < -1) {
                                tank.moveDir.y = -1;
                            }
                            break;
                        case 'a':
                        case 'A':
                            tank.moveDir.x += 1;
                            if (tank.moveDir.x > 1) {
                                tank.moveDir.x = 1;
                            }
                            break;
                    }
                }, false);
            }
            
            function tankHandleMouseMove(tank)
            {
                document.body.addEventListener('mousemove', function(e) {
                    var targetPos = new Victor(e.x - tank.world.view.x, e.y - tank.world.view.y);
                    var dir = targetPos.subtract(tank.sprite.position);
                    // TODO: rotate speed
                    tank.sprite.rotation = dir.angle() + Math.PI / 2;
                }, false);
            }
            
            function tankHandleMouseDown(tank) {
                document.body.addEventListener('mousedown', function(e) {
                    tank.fire();
                }, false);
            }
            
            function Tank(world, name, position)
            {
                this.world = world;
            
                this.id = Util.getId();
                this.cfg = Config.tanks[name];
                this.autoFire = true;
                this.moveDir = new Victor(0, 0);
            
                this.sprite = new PIXI.Container();
                this.weapons = [];
                for (var idx in this.cfg.weapons) {
                    var weapon = new Weapon(world, this, this.cfg.weapons[idx]);
                    this.weapons.push(weapon);
                    this.sprite.addChild(weapon.sprite);
                }
            
                var graphics = new PIXI.Graphics();
                graphics.lineStyle(this.cfg.edge.w, this.cfg.edge.color);
                graphics.beginFill(this.cfg.body.color);
                graphics.drawCircle(0, 0, this.cfg.body.radius);
                graphics.endFill();
                var bodySprite = new PIXI.Sprite(graphics.generateTexture());
                graphics.destroy();
            
                bodySprite.anchor.x = 0.5;
                bodySprite.anchor.y = 0.5;
                this.sprite.addChild(bodySprite);
            
                world.view.addChild(this.sprite);
            
                this.x = position.x;
                this.y = position.y;
                this.radius = this.cfg.body.radius + this.cfg.edge.w;
            
                // event handlers:
                tankHandleKeyDown(this);
                tankHandleKeyUp(this);
                tankHandleMouseMove(this);
                tankHandleMouseDown(this);
            
                // hp bar
                this.hpbar = new HpBar(world, Config.hpbar, this, true);
                this.hpbar.update(0.5);
            }
            
            Tank.prototype = {}
            
            Tank.prototype.update = function()
            {
                // update tank position
                if (this.moveDir.lengthSq() > 1e-6) {
                    var oldX = this.x;
                    var oldY = this.y;
            
                    var angle = this.moveDir.angle();
                    var deltaY = this.cfg.speed * Math.sin(angle) * Config.world.updateMS / 1000;
                    var deltaX = this.cfg.speed * Math.cos(angle) * Config.world.updateMS / 1000;
                    this.x += deltaX;
                    this.y += deltaY;
                    var cfg = Config.world.map;
                    Util.clampPosition(this, 0, cfg.w, 0, cfg.h);
            
                    this.hpbar.x += (this.x - oldX);
                    this.hpbar.y += (this.y - oldY);
                }
            
                // fire
                if (this.autoFire == true) {
                    this.fire();
                }
            }
            
            Tank.prototype.fire = function()
            {
                for (var idx in this.weapons) {
                    this.weapons[idx].fire();
                }
            }
            
            Object.defineProperties(Tank.prototype, {
                x: {
                    get: function() { return this.sprite.x; },
                    set: function(v) { this.sprite.x = v; }
                },
                y: {
                    get: function() { return this.sprite.y; },
                    set: function(v) { this.sprite.y = v; }
                },
                h: {
                    get: function() { return this.sprite.height; }
                },
                w: {
                    get: function() { return this.sprite.width; }
                },
            });
            
            module.exports = Tank;
            
        });
        </script>
        <script>
        require.register("./modules/weapon", function(module, exports, require) {
            var Bullet = require("../modules/bullet");
            
            function weaponCreateView(weapon)
            {
            }
            
            function Weapon(world, tank, cfg)
            {
                this.world = world;
                this.owner = tank;
                this.cfg = cfg;
                this.angle = this.cfg.angle;
                this.offset = new Victor(0, - this.cfg.shootOffset - this.cfg.h);
                this.offset.rotateDeg(this.cfg.angle)
                           .add(new Victor(this.cfg.x, this.cfg.y));
                this.fireFrame = world.frame + this.cfg.shootDelayFrame;
            
                var graphics = new PIXI.Graphics();
                graphics.lineStyle(this.owner.cfg.edge.w, this.owner.cfg.edge.color);
                graphics.beginFill(this.cfg.color);
                graphics.drawRect(0, 0, this.cfg.w, this.cfg.h);
                graphics.endFill();
                this.sprite = new PIXI.Sprite(graphics.generateTexture());
                graphics.destroy();
            
                this.sprite.anchor.x = 0.5;
                this.sprite.anchor.y = 1.0;
                this.sprite.rotation = this.cfg.angle * Math.PI / 180;
                this.sprite.x += this.cfg.x;
                this.sprite.y += this.cfg.y;
            }
            
            Weapon.prototype = {}
            
            Weapon.prototype.fire = function()
            {
                if (this.world.frame - this.fireFrame >= this.cfg.reloadFrame) {
            
                    this.fireFrame = this.world.frame;
            
                    var pos = this.offset.clone();
                    pos.rotate(this.owner.sprite.rotation);
                    pos.add(new Victor(this.owner.sprite.position.x, this.owner.sprite.position.y));
                    if (pos.x <= 0 || pos.y <= 0 || pos.x >= this.world.w || pos.y >= this.world.h) {
                        return;
                    }
            
                    var angle = this.owner.sprite.rotation + this.cfg.angle * Math.PI / 180 - Math.PI / 2;
                    var disturb = this.cfg.disturbDeg * Math.PI / 180;
                    angle += (Math.random() * disturb - disturb / 2);
            
                    var bullet = new Bullet(this.world, pos, angle, this);
                    this.world.bullets[bullet.id] = bullet;
                }
            }
            
            module.exports = Weapon;
            
        });
        </script>
        <script>
        require.register("./modules/world", function(module, exports, require) {
            var Config = require("../modules/config");
            var Obstacle = require("../modules/obstacle");
            var Tank = require("../modules/tank");
            var Util = require("../modules/util");
            
            function getWorldBackground()
            {
                var cfg = Config.world;
                var graphics = new PIXI.Graphics();
            
                // background walkable region
                graphics.beginFill(cfg.walkable.color);
                graphics.drawRect(cfg.walkable.x, cfg.walkable.y,
                    cfg.walkable.w, cfg.walkable.h);
                graphics.endFill();
            
                // background grids
                graphics.lineStyle(cfg.view.grid.edge, cfg.view.grid.color);
                for (var x = cfg.view.grid.size; x < cfg.map.w; x += cfg.view.grid.size) {
                    graphics.moveTo(x, 0);
                    graphics.lineTo(x, cfg.map.h);
                }
                for (var y = cfg.view.grid.size; y < cfg.map.h; y += cfg.view.grid.size) {
                    graphics.moveTo(0, y);
                    graphics.lineTo(cfg.map.w, y);
                }
            
                return graphics;
            }
            
            function World()
            {
                this.frame = 0;
            
                this.w = Config.world.map.w;
                this.h = Config.world.map.h;
            
                this.gridSize = Config.world.map.grid.size;
                this.gridW = this.w / this.gridSize;
                this.gridH = this.h / this.gridSize;
                this.grids = [];
                for (var i = 0; i < this.gridH; ++ i) {
                    for (var j = 0; j < this.gridW; ++ j) {
                        this.grids.push({});
                    }
                }
            
                var dateTime = new Date();
                this.time = dateTime.getTime();
            
                this.stage = new PIXI.Container();
            
                // main view (camera bind)
                this.view = new PIXI.Container();
                this.view.addChild(getWorldBackground());
                this.stage.addChild(this.view);
            
                // UI & HUD
                this.ui = new PIXI.Container();
                this.stage.addChild(this.ui);
            
                this.renderer = new PIXI.CanvasRenderer(Config.world.view.w, Config.world.view.h, {
                        backgroundColor: Config.world.map.color,
                        antialias: true,
                        autoResize: true,
                    });
                document.body.appendChild(this.renderer.view);
            
                // world objects
                this.bullets = {};
                this.obstacles = [];
                this.obstacleCount = 0;
                this.tank = new Tank(this, "normal", { x: this.w / 2, y: this.h / 2, });
            
                // die sprites
                this.dieSprites = [];
            }
            
            World.prototype = {};
            World.prototype.constructor = World;
            
            World.prototype.updateCamera = function()
            {
                var x = this.tank.x;
                var y = this.tank.y;
                var viewCenterX = Config.world.view.w / 2;
                var viewCenterY = Config.world.view.h / 2;
                x = Util.clamp(x, viewCenterX, this.w - viewCenterX);
                y = Util.clamp(y, viewCenterY, this.h - viewCenterY);
                this.view.x = viewCenterX - x;
                this.view.y = viewCenterY - y;
            }
            
            World.prototype.updateTanks = function()
            {
                var oldx = this.tank.x;
                var oldy = this.tank.y;
                this.tank.update();
                this.updateUnitGrid(this.tank, { x: oldx, y: oldy });
            }
            
            World.prototype.updatePlayers = function()
            {
                // TODO:
            }
            
            World.prototype.updateObstacles = function()
            {
                if (this.obstacleCount < Config.obstacles.count) {
                    var cfgs = [
                        Config.obstacles.small,
                        Config.obstacles.middle,
                        Config.obstacles.large
                    ];
                    var cfg = cfgs[Math.floor((Math.random() * cfgs.length))];
                    var wcfg = Config.world.walkable;
                    var obstacle = new Obstacle(this, cfg, {
                        x: Util.randomBetween(wcfg.x, wcfg.x + wcfg.w),
                        y: Util.randomBetween(wcfg.y, wcfg.y + wcfg.h),
                    });
                    this.obstacles[obstacle.id] = obstacle;
                    this.obstacleCount ++;
                }
            
                for (var i in this.obstacles) {
                    var obstacle = this.obstacles[i];
                    var oldx = obstacle.x;
                    var oldy = obstacle.y;
                    obstacle.update();
                    this.updateUnitGrid(obstacle, { x: oldx, y: oldy });
                }
            }
            
            World.prototype.updateBullets = function()
            {
                for (var i in this.bullets) {
                    var bullet = this.bullets[i];
                    if (bullet.outOfDate() || bullet.outOfBounds()) {
                        bullet.die();
                        delete bullet;
                    } else {
                        var oldx = bullet.x;
                        var oldy = bullet.y;
                        bullet.update();
                        this.updateUnitGrid(bullet, { x: oldx, y: oldy });
                    }
                }
            }
            
            World.prototype.getUnitsIn9Grids = function(x, y)
            {
                var targets = [];
                var idxs = [
                    (y - 1) * this.gridW + x - 1,
                    (y - 1) * this.gridW + x,
                    (y - 1) * this.gridW + x + 1,
                    y * this.gridW + x - 1,
                    y * this.gridW + x,
                    y * this.gridW + x + 1,
                    (y + 1) * this.gridW + x - 1,
                    (y + 1) * this.gridW + x,
                    (y + 1) * this.gridW + x + 1,
                ];
            
                var x1 = (x >= 1);
                var x2 = (x < this.gridW - 1);
            
                var y1 = (y >= 1);
                var y2 = (y < this.gridH - 1);
            
                if (y1 && x1) {
                    var g = this.grids[idxs[0]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (y1) {
                    var g = this.grids[idxs[1]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (y1 && x2) {
                    var g = this.grids[idxs[2]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (x1) {
                    var g = this.grids[idxs[3]];
                    for (var i in g) { targets.push(g[i]); }
                }
                {
                    var g = this.grids[idxs[4]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (x2) {
                    var g = this.grids[idxs[5]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (y2 && x1) {
                    var g = this.grids[idxs[6]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (y2) {
                    var g = this.grids[idxs[7]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (y2 && x2) {
                    var g = this.grids[idxs[8]];
                    for (var i in g) { targets.push(g[i]); }
                }
                return targets;
            }
            
            World.prototype.needCheckCollision = function(unit, target)
            {
                var u1 = (unit.owner == null ? unit : unit.owner);
                var u2 = (target.owner == null ? target : target.owner);
                return u1 != u2;
            }
            
            World.prototype.updateCollision = function()
            {
                for (var x = 0; x < this.gridW; ++ x) {
                    for (var y = 0; y < this.gridH; ++ y) {
                        var idx = y * this.gridW + x;
                        for (var i in this.grids[idx]) {
                            var unit = this.grids[idx][i];
                            var targets = this.getUnitsIn9Grids(x, y);
                            for (var j in targets) {
                                var target = targets[j];
                                if (this.needCheckCollision(unit, target) == false) {
                                    continue;
                                }
                                if (target.collideCheckFrame == this.frame) {
                                    continue;
                                }
                                var distX = unit.x - target.x;
                                var distY = unit.y - target.y;
                                var distR = unit.radius + target.radius;
                                if (distX * distX + distY * distY < distR * distR) {
                                    // TODO: collision
                                }
                            }
                            unit.collideCheckFrame = this.frame;
                        }
                    }
                }
            }
            
            World.prototype.updateDieAnimations = function()
            {
                var cfg = Config.dieAnimation;
                for (var i in this.dieSprites) {
                    var sprite = this.dieSprites[i];
                    if (sprite.alpha > cfg.alphaStart) {
                        sprite.alpha = cfg.alphaStart;
                    } else {
                        sprite.alpha -= cfg.alphaDecrease;;
                    }
                    sprite.scale.x += cfg.scaleIncrease;
                    sprite.scale.y += cfg.scaleIncrease;
                    if (sprite.alpha < cfg.alphaEnd) {
                        var idx = this.view.getChildIndex(sprite);
                        this.view.removeChildAt(idx);
                        this.dieSprites.splice(i, 1);
                        delete sprite;
                    }
                }
            }
            
            World.prototype.updateLogic = function()
            {
                var dateTime = new Date();
                var ms = dateTime.getTime();
                while (ms > this.time + Config.world.updateMS) {
                    this.time += Config.world.updateMS;
                    this.frame ++;
                    this.updateTanks();
                    this.updatePlayers();
                    this.updateObstacles();
                    this.updateBullets();
                    this.updateCollision();
                    this.updateDieAnimations();
                }
            }
            
            World.prototype.updateUnitGrid = function(unit, oldPos)
            {
                if (oldPos.x == unit.x && oldPos.y == unit.y) {
                    return;
                }
            
                var ogx = Math.floor(oldPos.x / this.gridSize);
                var ogy = Math.floor(oldPos.y / this.gridSize);
                var oidx = ogy * this.gridW + ogx;
            
                var gx = Math.floor(unit.x / this.gridSize);
                var gy = Math.floor(unit.y / this.gridSize);
                var idx = gy * this.gridW + gx;
            
                if (idx != oidx) {
                    delete this.grids[oidx][unit.id];
                }
                this.grids[idx][unit.id] = unit;
            }
            
            World.prototype.removeUnitFromGrid = function(unit)
            {
                var gx = Math.floor(unit.x / this.gridSize);
                var gy = Math.floor(unit.y / this.gridSize);
                var idx = gy * this.gridW + gx;
                delete this.grids[idx][unit.id];
            }
            
            World.prototype.update = function()
            {
                this.updateLogic();
                this.updateCamera();
                this.renderer.render(this.stage);
            }
            
            module.exports = World;
            
        });
        </script>
        <script>
        require.register("./modules/util", function(module, exports, require) {
            var Util = {
            
                id: 0,
            
                unitType: {
                    "tank": 1,
                    "weapon": 2,
                    "bullet": 3,
                    "obstacle": 4
                },
            
                clamp: function(value, min, max) {
                    if (value > max) {
                        value = max;
                    }
                    if (value < min) {
                        value = min;
                    }
                    return value;
                },
            
                clampPosition: function(pos, minx, maxx, miny, maxy) {
                    if (pos.x > maxx) {
                        pos.x = maxx;
                    }
                    if (pos.x < minx) {
                        pos.x = minx;
                    }
                    if (pos.y > maxy) {
                        pos.y = maxy;
                    }
                    if (pos.y < miny) {
                        pos.y = miny;
                    }
                },
            
                randomBetween: function(min, max) {
                    return Math.random() * (max - min) + min;
                },
            
                getId: function() {
                    return ++ this.id;
                },
            };
            
            module.exports = Util;
        });
        </script>

        <script src="./main.js"></script>
    </body>
</html>
