<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>tank</title>
        <meta name="description" content="">
        <meta name="format-detection" content="telephone-no">
        <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width, minimal-ui">
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="format-detection" content="telephone=no">
    </head>
    <body>
        <script src="./lib/pixi.min.js"></script>
        <script src="./lib/victor.min.js"></script>
        <script src="./lib/require.js"></script>

        <!-- require modules -->
        <script>
        require.register("./modules/config", function(module, exports, require) {
            var Config =
            {
                world: {
                    map: {
                        w: 2048,
                        h: 2048,
                        color: 0x808080,
                        grid: {
                            size: 128,
                        },
                    },
                    view: {
                        w: document.documentElement.clientWidth,
                        h: document.documentElement.clientHeight - 10,
                        grid: {
                            size: 32,
                            edge: 1,
                            color: 0xa0a0a0
                        },
                    },
                    obstacleSpawn: {
                        wRatio: 0.92,
                        hRatio: 0.92,
                        color: 0xcdcdcd,
                        maxCount: 50,
                    },
                    unitCollideCheckMS: 500,
                    updateMS: 1000 / 30,
                    springVelocityBase: 20,
                    springVelocityAdd: 30,
                },
            
                hpbar: {
                    edge: {
                        w: 4,
                        color: 0x555555,
                    },
                    w: 100,
                    h: 20,
                    radius: 10,
                    color: 0x86c680,
                    xOffsetRatio: 0,
                    yOffsetRatio: 1.4,
                    xDisplayRatio: 0.6,
                    yDisplayRatio: 0.6,
                    alpha: 0.75,
                },
            
                dieAnimation: {
                    alphaStart: 0.4,
                    alphaDecrease: 0.1,
                    alphaEnd: 0.1,
                    scaleIncrease: 0.1
                },
            
                bullets: {
                    normal: {
                        edge: {
                            w: 2,
                            color: 0x555555
                        },
                        body: {
                            radius: 8,
                            color: 0xf14e54,
                            playerColor: 0x00b2e1,
                        },
                        duration: 1000,
                        hp: 1,
                        damage: 10,
                        density: 1,
                        velocity: {
                            ivInit: 300,
                            ivAcc: 200,
                            ivMax: 300,
                            ivMin: 200,
                            evDec: 80,
                            evMax: 160,
                            rotate: 0,
                        },
                    }
                },
            
                obstacles: {
                    small: {
                        side: 3,
                        radius: 20,
                        color: 0xfc7676,
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        hp: 20,
                        damage: 2,
                        density: 1,
                        velocity: {
                            ivInit: 3,
                            ivAcc: 0,
                            ivMax: 3,
                            ivMin: 3,
                            evDec: 80,
                            evMax: 160,
                            rotate: 0.5,
                        },
                    },
                    middle: {
                        side: 4,
                        radius: 20,
                        color: 0xffe869,
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        hp: 40,
                        damage: 4,
                        density: 1,
                        velocity: {
                            ivInit: 3,
                            ivAcc: 0,
                            ivMax: 3,
                            ivMin: 3,
                            evDec: 80,
                            evMax: 160,
                            rotate: 0.5,
                        },
                    },
                    large: {
                        side: 5,
                        radius: 24,
                        color: 0x768dfc,
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        hp: 80,
                        damage: 8,
                        density: 1,
                        velocity: {
                            ivInit: 3,
                            ivAcc: 0,
                            ivMax: 3,
                            ivMin: 3,
                            evDec: 80,
                            evMax: 160,
                            rotate: 0.5,
                        },
                    },
                },
            
                tanks: {
                    base: {
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        body: {
                            radius: 22,
                            color: 0xf14e54,
                            playerColor: 0x00b2e1,
                        },
                        weapons: [
                            {
                                w: 15,
                                h: 35,
                                x: 0,
                                y: 0,
                                bullet: "normal",
                                angle: 0,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 3,
                                disturbDeg: 15,
                                recoil: 10000,
                                fireAnimFrame: 16,
                                fireAnimDistance: 5,
                            },
                        ],
                        hp: 1000,
                        damage: 10,
                        density: 1,
                        velocity: {
                            ivInit: 0,
                            ivAcc: 400,
                            ivMax: 160,
                            ivMin: 0,
                            evDec: 80,
                            evMax: 160,
                            rotate: 0,
                        },
                    },
                    twin: {
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        body: {
                            radius: 24,
                            color: 0xf14e54,
                            playerColor: 0x00b2e1,
                        },
                        weapons: [
                            {
                                w: 12,
                                h: 40,
                                x: -8,
                                y: 0,
                                bullet: "normal",
                                angle: 0,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 3,
                                disturbDeg: 15,
                                recoil: 10000,
                                fireAnimFrame: 16,
                                fireAnimDistance: 5,
                            },
                            {
                                w: 12,
                                h: 40,
                                x: 8,
                                y: 0,
                                bullet: "normal",
                                angle: 0,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 6,
                                disturbDeg: 15,
                                recoil: 10000,
                                fireAnimFrame: 16,
                                fireAnimDistance: 5,
                            }
                        ],
                        hp: 2000,
                        damage: 10,
                        density: 1,
                        velocity: {
                            ivInit: 0,
                            ivAcc: 400,
                            ivMax: 160,
                            ivMin: 0,
                            evDec: 80,
                            evMax: 160,
                            rotate: 0,
                        },
                    },
                    quad: {
                        edge: {
                            w: 2.5,
                            color: 0x555555
                        },
                        body: {
                            radius: 24,
                            color: 0xf14e54,
                            playerColor: 0x00b2e1,
                        },
                        weapons: [
                            {
                                w: 16,
                                h: 38,
                                x: 0,
                                y: 0,
                                bullet: "normal",
                                angle: 0,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 3,
                                disturbDeg: 15,
                                recoil: 10000,
                                fireAnimFrame: 16,
                                fireAnimDistance: 5,
                            },
                            {
                                w: 16,
                                h: 38,
                                x: 0,
                                y: 0,
                                bullet: "normal",
                                angle: 90,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 6,
                                disturbDeg: 15,
                                recoil: 10000,
                                fireAnimFrame: 16,
                                fireAnimDistance: 5,
                            },
                            {
                                w: 16,
                                h: 38,
                                x: 0,
                                y: 0,
                                bullet: "normal",
                                angle: 180,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 3,
                                disturbDeg: 15,
                                recoil: 10000,
                                fireAnimFrame: 16,
                                fireAnimDistance: 5,
                            },
                            {
                                w: 16,
                                h: 38,
                                x: 0,
                                y: 0,
                                bullet: "normal",
                                angle: 270,
                                color: 0x999999,
                                shootOffset: 10,
                                reloadFrame: 10,
                                shootDelayFrame: 6,
                                disturbDeg: 15,
                                recoil: 10000,
                                fireAnimFrame: 16,
                                fireAnimDistance: 5,
                            },
                        ],
                        hp: 2000,
                        damage: 10,
                        density: 1,
                        velocity: {
                            ivInit: 0,
                            ivAcc: 400,
                            ivMax: 160,
                            ivMin: 0,
                            evDec: 80,
                            evMax: 160,
                            rotate: 0,
                        },
                    },
                }
            };
            
            module.exports = Config;
        });
        </script>
        <script>
        require.register("./modules/bullet", function(module, exports, require) {
            var Config = require("../modules/config");
            var Motion = require("../modules/motion");
            var Util = require("../modules/util");
            
            function Bullet(world, position, angle, weapon)
            {
                this.id = Util.getId();
                this.type = Util.unitType.bullet;
                this.world = world;
                this.owner = weapon.owner;
                this.bornTime = world.time;
                this.cfg = Config.bullets[weapon.cfg.bullet];
                this.hp = this.cfg.hp;
                this.damage = this.cfg.damage;
                this.density = this.cfg.density;
                this.motion = new Motion(this, this.cfg.velocity, angle);
            
                // view
                var graphics = new PIXI.Graphics();
                graphics.lineStyle(this.cfg.edge.w, this.cfg.edge.color);
                if (this.world.player.tank == this.owner) {
                    graphics.beginFill(this.cfg.body.playerColor);
                } else {
                    graphics.beginFill(this.cfg.body.color);
                }
                graphics.drawCircle(0, 0, this.cfg.body.radius);
                graphics.endFill();
                var bodySprite = new PIXI.Sprite(graphics.generateTexture());
                graphics.destroy();
                bodySprite.anchor.x = 0.5;
                bodySprite.anchor.y = 0.5;
                this.sprite = new PIXI.Container();
                this.sprite.addChild(bodySprite);
                world.view.addChild(this.sprite);
            
                this.x = position.x;
                this.y = position.y;
                world.addUnitToGrid(this);
            }
            
            Bullet.prototype = {}
            
            Bullet.prototype.outOfBounds = function()
            {
                if (this.x <= 0 || this.x >= this.world.w
                    || this.y <= 0 || this.y >= this.world.h) {
                    return true;
                }
                return false;
            }
            
            Bullet.prototype.outOfDate = function()
            {
                if (this.world.time > this.bornTime + this.cfg.duration) {
                    return true;
                }
                return false;
            }
            
            Bullet.prototype.takeDamageByUnit = function(caster)
            {
                this.hp -= caster.damage;
                if (this.hp <= 0) {
                    this.die();
                }
            }
            
            Bullet.prototype.die = function()
            {
                delete this.world.bullets[this.id];
                this.world.dieSprites.push(this.sprite);
                this.world.removeUnitFromGrid(this);
                this.world.removeUnits.push(this);
            }
            
            Bullet.prototype.update = function()
            {
                this.motion.update(Config.world.updateMS);
            }
            
            Object.defineProperties(Bullet.prototype, {
                x: {
                    get: function() { return this.sprite.x; },
                    set: function(v) { this.sprite.x = v; }
                },
                y: {
                    get: function() { return this.sprite.y; },
                    set: function(v) { this.sprite.y = v; }
                },
                radius: {
                    get: function() { return this.cfg.body.radius + this.cfg.edge.w; }
                },
                m: {
                    get: function() { return this.radius * this.radius * this.density; }
                },
            });
            
            module.exports = Bullet;
            
        });
        </script>
        <script>
        require.register("./modules/hpbar", function(module, exports, require) {
            var Config = require("../modules/config");
            var Util = require("../modules/util");
            
            function HpBar(world, cfg, owner, display)
            {
                this.world = world;
                this.cfg = cfg;
                this.owner = owner;
                this.display = display;
                this.percent = 1;
            
                var graphics = new PIXI.Graphics();
                graphics.lineStyle(this.cfg.edge.w, this.cfg.edge.color);
                graphics.beginFill(this.cfg.edge.color);
                graphics.drawRoundedRect(0, 0, this.cfg.w, this.cfg.h, this.cfg.radius);
                graphics.endFill();
                this.backSprite = new PIXI.Sprite(graphics.generateTexture());
                this.backSprite.anchor.x = 0.5;
                this.backSprite.anchor.y = 0.5;
            
                graphics.lineStyle(this.cfg.edge.w, this.cfg.edge.color);
                graphics.beginFill(this.cfg.color);
                graphics.drawRoundedRect(0, 0, this.cfg.w, this.cfg.h, this.cfg.radius);
                graphics.endFill();
                this.frontSprite = new PIXI.Sprite(graphics.generateTexture());
                this.frontSprite.anchor.x = 0.5;
                this.frontSprite.anchor.y = 0.5;
            
                this.sprite = new PIXI.Container();
                this.sprite.addChild(this.backSprite);
                this.sprite.addChild(this.frontSprite);
                this.sprite.alpha = this.cfg.alpha;
            
                this.x = this.owner.x + this.owner.radius * this.cfg.xOffsetRatio;
                this.y = this.owner.y + this.owner.radius * this.cfg.yOffsetRatio;
            
                this.scale.x = this.cfg.xDisplayRatio * 2 * this.owner.radius / this.cfg.w;
                this.scale.y = this.cfg.yDisplayRatio * 2 * this.owner.radius / this.cfg.w;
            
                world.view.addChild(this.sprite);
            }
            
            HpBar.prototype = {}
            
            HpBar.prototype.die = function()
            {
                if (this.sprite && this.sprite.parent != null) {
                    this.sprite.parent.removeChild(this.sprite);
                }
                delete this.sprite;
            }
            
            HpBar.prototype.update = function(percent)
            {
                if (Math.abs(percent - 1) < 1e-6 && this.display == false) {
                    this.visible = false;
                } else {
                    this.visible = true;
                }
            
                if (this.percent == percent) {
                    return;
                }
            
                this.frontSprite.x += this.cfg.w * (1 - this.percent) / 2;
                this.percent = percent;
                this.frontSprite.width = this.cfg.w * percent;
                this.frontSprite.x -= this.cfg.w * (1 - this.percent) / 2;
            }
            
            Object.defineProperties(HpBar.prototype, {
                x: {
                    get: function() { return this.sprite.x; },
                    set: function(v) { this.sprite.x = v; }
                },
                y: {
                    get: function() { return this.sprite.y; },
                    set: function(v) { this.sprite.y = v; }
                },
                scale: {
                    get: function() { return this.sprite.scale; },
                    set: function(s) { this.sprite.scale = s; }
                },
                visible: {
                    get: function() { return this.sprite.visible; },
                    set: function(v) { this.sprite.visible = v; }
                },
                w: {
                    get: function() { return this.sprite.width; }
                },
                h: {
                    get: function() { return this.sprite.height; }
                },
            });
            
            module.exports = HpBar;
            
        });
        </script>
        <script>
        require.register("./modules/motion", function(module, exports, require) {
            var Config = require("../modules/config");
            var Util = require("../modules/util");
            
            var epsilon = 1e-6;
            
            function Motion(owner, cfg, angle)
            {
                this.owner = owner;
                this.moveDir = new Victor(0, 0);
                this.iv = new Victor(cfg.ivInit * Math.cos(angle),
                    cfg.ivInit * Math.sin(angle));
                this.ev = new Victor(0, 0);
                this.ivAcc = cfg.ivAcc;
                this.ivMax = cfg.ivMax;
                this.ivMin = cfg.ivMin;
                this.evDec = cfg.evDec;
                this.evMax = cfg.evMax;
                this.rotate = cfg.rotate;
            }
            
            Motion.prototype = {}
            
            Motion.prototype.toString = function()
            {
                return "unit[" + this.owner.id + "] "
                    + "move dir={" + this.moveDir.x + "," + this.moveDir.y + "} "
                    + "iv={" + this.iv.x + "," + this.iv.y + "} "
                    + "ev={" + this.ev.x + "," + this.ev.y + "} "
                    + "v=" + this.v;
            }
            
            Motion.prototype.randomMoveDir = function()
            {
                var angle = Math.random() * Math.PI * 2;
                this.moveDir.x = Math.cos(angle);
                this.moveDir.y = Math.sin(angle);
            }
            
            Motion.prototype.setMoveDirByAngle = function(angle)
            {
                this.moveDir.x = Math.cos(angle);
                this.moveDir.y = Math.sin(angle);
            }
            
            Motion.prototype.setMoveDirByFlag = function(left, right, up, down)
            {
                this.moveDir.x = 0;
                this.moveDir.y = 0;
                if (left == 1) {
                    this.moveDir.x -= 1;
                }
                if (right == 1) {
                    this.moveDir.x += 1;
                }
                if (up == 1) {
                    this.moveDir.y -= 1;
                }
                if (down == 1) {
                    this.moveDir.y += 1;
                }
            }
            
            Motion.prototype.reverseMoveDirX = function()
            {
                this.moveDir.x = -this.moveDir.x;
            }
            
            Motion.prototype.reverseMoveDirY = function()
            {
                this.moveDir.y = -this.moveDir.y;
            }
            
            Motion.prototype.addRecoil = function(recoil, angle)
            {
                this.ev.x -= recoil * Math.cos(angle);
                this.ev.y -= recoil * Math.sin(angle);
            }
            
            Motion.prototype.update = function(deltaMS)
            {
                // internal velocity decrese
                var ilen = this.iv.length();
                if (ilen > this.ivMin) {
                    var dec = (this.ivAcc / 2) * deltaMS / 1000;
                    ilen = ilen > dec ? (ilen - dec) : 0;
                    ilen = ilen < this.ivMin ? this.ivMin : ilen;
                    this.iv.norm().multiply(new Victor(ilen, ilen));
                }
            
                // internal velocity increse
                if (this.moveDir.length() > epsilon) {
                    var angle = this.moveDir.angle();
                    this.iv.x += this.ivAcc * Math.cos(angle) * deltaMS / 1000;
                    this.iv.y += this.ivAcc * Math.sin(angle) * deltaMS / 1000;
                    var ilen = this.iv.length();
                    if (ilen > this.ivMax) {
                        ilen = this.ivMax;
                        this.iv.norm().multiply(new Victor(ilen, ilen));
                    }
                }
            
                // eternal velocity decrese
                var elen = this.ev.length();
                if (elen > epsilon) {
                    var dec = this.evDec * deltaMS / 1000;
                    elen = elen > dec ? (elen - dec) : 0;
                    elen = elen > this.evMax ? this.evMax : elen;
                    this.ev.norm().multiply(new Victor(elen, elen));
                }
            
                // update position
                this.owner.x += (this.iv.x + this.ev.x) * deltaMS / 1000;
                this.owner.y += (this.iv.y + this.ev.y) * deltaMS / 1000;
            
                var cfg = Config.world.map;
                Util.clampPosition(this.owner, 0, cfg.w, 0, cfg.h);
            
                if (this.rotate != null && Math.abs(this.rotate) > epsilon) {
                    this.owner.sprite.rotation += this.rotate * deltaMS / 1000;
                }
            }
            
            Object.defineProperties(Motion.prototype, {
                vx: {
                    get: function() { return this.iv.x + this.ev.x; }
                },
                vy: {
                    get: function() { return this.iv.y + this.ev.y; }
                },
                v: {
                    get: function() { return Math.sqrt(this.vx * this.vx + this.vy * this.vy); }
                },
            });
            
            module.exports = Motion;
        });
        </script>
        <script>
        require.register("./modules/obstacle", function(module, exports, require) {
            var Config = require("../modules/config");
            var HpBar = require("../modules/hpbar");
            var Motion = require("../modules/motion");
            var Util = require("../modules/util");
            
            function Obstacle(world, cfg, position)
            {
                this.world = world;
                this.id = Util.getId();
                this.type = Util.unitType.obstacle;
                this.cfg = cfg;
                this.hp = this.cfg.hp;
                this.fullHp = this.cfg.hp;
                this.damage = this.cfg.damage;
                this.density = this.cfg.density;
            
                // view
                this.sprite = new PIXI.Container();
                var graphics = new PIXI.Graphics();
                graphics.lineStyle(this.cfg.edge.w, this.cfg.edge.color);
                graphics.beginFill(this.cfg.color);
                var from = new PIXI.Point(0, - this.cfg.radius);
                graphics.moveTo(from.x, from.y);
                for (var i = 1; i < this.cfg.side; ++ i) {
                    var p = new Victor(from.x, from.y);
                    p.rotate(Math.PI * 2 / this.cfg.side);
                    graphics.lineTo(p.x, p.y);
                    from.set(p.x, p.y);
                    delete p;
                }
                graphics.endFill();
                delete from;
                var bodySprite = new PIXI.Sprite(graphics.generateTexture());
                graphics.destroy();
                bodySprite.pivot.x = bodySprite.width / 2;
                bodySprite.pivot.y = this.cfg.radius + this.cfg.edge.w;
                this.sprite.addChild(bodySprite);
                world.view.addChild(this.sprite);
            
                this.x = position.x;
                this.y = position.y;
                world.addUnitToGrid(this);
            
                var angle = Math.random() * Math.PI * 2;
                this.motion = new Motion(this, this.cfg.velocity, angle);
                this.hpbar = new HpBar(world, Config.hpbar, this, false);
            }
            
            Obstacle.prototype = {}
            
            Obstacle.prototype.takeDamageByUnit = function(caster)
            {
                this.hp -= caster.damage;
                if (this.hp <= 0) {
                    this.die();
                }
            }
            
            Obstacle.prototype.die = function()
            {
                this.hpbar.die();
                this.world.dieSprites.push(this.sprite);
            
                delete this.world.obstacles[this.id];
                -- this.world.obstacleCount;
                this.world.removeUnitFromGrid(this);
                this.world.removeUnits.push(this);
            }
            
            Obstacle.prototype.update = function()
            {
                var oldX = this.x;
                var oldY = this.y;
                this.motion.update(Config.world.updateMS);
            
                this.hpbar.update(this.hp / this.fullHp);
                this.hpbar.x += (this.x - oldX);
                this.hpbar.y += (this.y - oldY);
            
                if (this.x < this.world.spawnRegion.x
                    || this.x > this.world.spawnRegion.x + this.world.spawnRegion.w) {
                    this.motion.reverseMoveDirX();
                }
                if (this.y < this.world.spawnRegion.y
                    || this.y > this.world.spawnRegion.y + this.world.spawnRegion.h) {
                    this.motion.reverseMoveDirY();
                }
            }
            
            Object.defineProperties(Obstacle.prototype, {
                x: {
                    get: function() { return this.sprite.x; },
                    set: function(v) { this.sprite.x = v; }
                },
                y: {
                    get: function() { return this.sprite.y; },
                    set: function(v) { this.sprite.y = v; }
                },
                radius: {
                    get: function() { return this.cfg.radius + this.cfg.edge.w; }
                },
                m: {
                    get: function() { return this.radius * this.radius * this.density; }
                },
                h: {
                    get: function() { return this.sprite.height; }
                },
                w: {
                    get: function() { return this.sprite.width; }
                },
            });
            
            module.exports = Obstacle;
        });
        </script>
        <script>
        require.register("./modules/player", function(module, exports, require) {
            var Tank = require("../modules/tank");
            var Util = require("../modules/util");
            
            function Player(world)
            {
                this.world = world;
                this.tank = null;
                this.control = {
                    left: 0,
                    right: 0,
                    up: 0,
                    down: 0,
                };
            }
            
            Player.prototype = {}
            
            Player.prototype.handleKeyDown = function()
            {
                var player = this;
                document.body.addEventListener('keydown', function(e) {
                    if (player.tank == null) {
                        return;
                    }
                    switch (e.key) {
                        case 'w':
                        case 'W':
                            player.control.up = 1;
                            break;
                        case 'd':
                        case 'D':
                            player.control.right = 1;
                            break;
                        case 's':
                        case 'S':
                            player.control.down = 1;
                            break;
                        case 'a':
                        case 'A':
                            player.control.left = 1;
                            break;
                    }
                }, false);
            }
            
            Player.prototype.handleKeyUp = function()
            {
                var player = this;
                document.body.addEventListener('keyup', function(e) {
                    if (player.tank == null) {
                        return;
                    }
                    switch (e.key) {
                        case 'w':
                        case 'W':
                            player.control.up = 0;
                            break;
                        case 'd':
                        case 'D':
                            player.control.right = 0;
                            break;
                        case 's':
                        case 'S':
                            player.control.down = 0;
                            break;
                        case 'a':
                        case 'A':
                            player.control.left = 0;
                            break;
                    }
                }, false);
            }
            
            Player.prototype.handleMouseMove = function()
            {
                var player = this;
                document.body.addEventListener('mousemove', function(e) {
                    var targetPos = new Victor(e.offsetX - player.world.view.x, e.offsetY - player.world.view.y);
                    if (player.tank != null) {
                        var dir = targetPos.subtract(new Victor(player.tank.x, player.tank.y));
                        player.tank.rotation = dir.angle() + Math.PI / 2;
                    }
                }, false);
            }
            
            Player.prototype.handleMouseDown = function()
            {
                var player = this;
                document.body.addEventListener('mousedown', function(e) {
                    if (player.tank != null) {
                        player.tank.revertFireStatus();
                    }
                }, false);
            }
            
            Player.prototype.addControl = function()
            {
                this.handleKeyDown();
                this.handleKeyUp();
                this.handleMouseMove();
                this.handleMouseDown();
            }
            
            Player.prototype.resetControl = function()
            {
                this.control.left = 0;
                this.control.right = 0;
                this.control.up = 0;
                this.control.down = 0;
            }
            
            Player.prototype.update = function()
            {
                if (!this.tank) {
                    this.tank = new Tank(this.world, "base", {
                        x: Math.random() * this.world.w,
                        y: Math.random() * this.world.h
                    }, this);
                    this.world.tanks[this.tank.id] = this.tank;
                    this.resetControl();
                }
                // motion move direction
                else {
                    this.tank.motion.setMoveDirByFlag(this.control.left,
                        this.control.right,
                        this.control.up,
                        this.control.down);
                }
            }
            
            Object.defineProperties(Player.prototype, {
                x: {
                    get: function() { return this.tank.x; }
                },
                y: {
                    get: function() { return this.tank.y; }
                },
            });
            
            module.exports = Player;
            
        });
        </script>
        <script>
        require.register("./modules/tank", function(module, exports, require) {
            var Config = require("../modules/config");
            var HpBar = require("../modules/hpbar");
            var Motion = require("../modules/motion");
            var Weapon = require("../modules/weapon");
            var Util = require("../modules/util");
            
            function Tank(world, name, position, player)
            {
                this.world = world;
                this.id = Util.getId();
                this.type = Util.unitType.tank;
                this.cfg = Config.tanks[name];
                this.player = player;
                this.hp = this.cfg.hp;
                this.fullHp = this.cfg.hp;
                this.damage = this.cfg.damage;
                this.density = this.cfg.density;
            
                // view & weapons
                this.sprite = new PIXI.Container();
                this.weapons = [];
                for (var idx in this.cfg.weapons) {
                    var weapon = new Weapon(world, this, this.cfg.weapons[idx]);
                    this.weapons.push(weapon);
                    this.sprite.addChild(weapon.sprite);
                }
                var graphics = new PIXI.Graphics();
                graphics.lineStyle(this.cfg.edge.w, this.cfg.edge.color);
                if (this.player) {
                    graphics.beginFill(this.cfg.body.playerColor);
                } else {
                    graphics.beginFill(this.cfg.body.color);
                }
                graphics.drawCircle(0, 0, this.cfg.body.radius);
                graphics.endFill();
                var bodySprite = new PIXI.Sprite(graphics.generateTexture());
                graphics.destroy();
                bodySprite.anchor.x = 0.5;
                bodySprite.anchor.y = 0.5;
                this.sprite.addChild(bodySprite);
                world.view.addChild(this.sprite);
            
                this.x = position.x;
                this.y = position.y;
                world.addUnitToGrid(this);
            
                this.motion = new Motion(this, this.cfg.velocity, 0);
                this.hpbar = new HpBar(world, Config.hpbar, this, true);
            }
            
            Tank.prototype = {}
            
            Tank.prototype.takeDamageByUnit = function(caster)
            {
                this.hp -= caster.damage;
                if (this.hp <= 0) {
                    this.die();
                }
            }
            
            Tank.prototype.die = function()
            {
                this.hpbar.die();
                this.world.dieSprites.push(this.sprite);
            
                delete this.world.tanks[this.id];
                this.world.removeUnitFromGrid(this);
                this.world.removeUnits.push(this);
            
                if (this.world.player.tank == this) {
                    this.world.player.tank = null;
                    this.world.gameend = true;
                    alert("Lose! Click To Restart!");
                    this.world.player.update();
                }
            }
            
            Tank.prototype.update = function()
            {
                var oldX = this.x;
                var oldY = this.y;
                this.motion.update(Config.world.updateMS);
            
                this.hpbar.update(this.hp / this.fullHp);
                this.hpbar.x += (this.x - oldX);
                this.hpbar.y += (this.y - oldY);
            
                if (this.autoFire == true) {
                    this.fire();
                }
            
                for (var idx in this.weapons) {
                    this.weapons[idx].update();
                }
            }
            
            Tank.prototype.fire = function()
            {
                for (var idx in this.weapons) {
                    this.weapons[idx].fire();
                }
            }
            
            Tank.prototype.revertFireStatus = function()
            {
                if (this.autoFire == true) {
                    this.autoFire = false;
                } else {
                    this.autoFire = true;
                    for (var idx in this.weapons) {
                        this.weapons[idx].resetFireDelay();
                    }
                }
            }
            
            Object.defineProperties(Tank.prototype, {
                x: {
                    get: function() { return this.sprite.x; },
                    set: function(v) { this.sprite.x = v; }
                },
                y: {
                    get: function() { return this.sprite.y; },
                    set: function(v) { this.sprite.y = v; }
                },
                radius: {
                    get: function() { return this.cfg.body.radius + this.cfg.edge.w; }
                },
                m: {
                    get: function() { return this.radius * this.radius * this.density; }
                },
                h: {
                    get: function() { return this.sprite.height; }
                },
                w: {
                    get: function() { return this.sprite.width; }
                },
                rotation: {
                    get: function() { return this.sprite.rotation; },
                    set: function(r) { this.sprite.rotation = r; }
                },
            });
            
            module.exports = Tank;
            
        });
        </script>
        <script>
        require.register("./modules/weapon", function(module, exports, require) {
            var Bullet = require("../modules/bullet");
            var Util = require("../modules/util");
            
            function weaponCreateView(weapon)
            {
            }
            
            function Weapon(world, tank, cfg)
            {
                this.world = world;
                this.id = Util.getId();
                this.type = Util.unitType.weapon;
                this.owner = tank;
                this.cfg = cfg;
                this.angle = this.cfg.angle;
                this.offset = new Victor(0, - this.cfg.shootOffset - this.cfg.h);
                this.offset.rotateDeg(this.cfg.angle)
                           .add(new Victor(this.cfg.x, this.cfg.y));
                this.fireFrame = world.frame + this.cfg.shootDelayFrame;
            
                // view
                var graphics = new PIXI.Graphics();
                graphics.lineStyle(this.owner.cfg.edge.w, this.owner.cfg.edge.color);
                graphics.beginFill(this.cfg.color);
                graphics.drawRect(0, 0, this.cfg.w, this.cfg.h);
                graphics.endFill();
                var bodySprite = new PIXI.Sprite(graphics.generateTexture());
                graphics.destroy();
                bodySprite.anchor.x = 0.5;
                bodySprite.anchor.y = 1.0;
                this.sprite = new PIXI.Container();
                this.sprite.addChild(bodySprite);
            
                // rotation & position
                this.rotation = this.cfg.angle * Math.PI / 180;
                this.x += this.cfg.x;
                this.y += this.cfg.y;
            
                // fire animation
                this.fireAnimFrame = null;
                this.originalX = this.x;
                this.originalY = this.y;
            }
            
            Weapon.prototype = {}
            
            Weapon.prototype.resetFireDelay = function()
            {
                this.fireFrame = this.world.frame + this.cfg.shootDelayFrame;
            }
            
            Weapon.prototype.update = function()
            {
                if (this.fireAnimFrame) {
                    var frame = this.world.frame - this.fireAnimFrame;
                    if (frame > this.cfg.fireAnimFrame) {
                        this.fireAnimFrame = null;
                    } else {
                        var delta = Math.abs(frame / this.cfg.fireAnimFrame * 2 - 1) * this.cfg.fireAnimDistance;
                        this.x = this.originalX + Math.cos(this.rotation + Math.PI / 2) * delta;
                        this.y = this.originalY + Math.sin(this.rotation + Math.PI / 2) * delta;
                    }
                }
            }
            
            Weapon.prototype.fire = function()
            {
                if (this.world.frame - this.fireFrame >= this.cfg.reloadFrame) {
            
                    this.fireFrame = this.world.frame;
                    this.fireAnimFrame = this.world.frame;
            
                    var pos = this.offset.clone();
                    pos.rotate(this.owner.rotation);
                    pos.add(new Victor(this.owner.sprite.position.x, this.owner.sprite.position.y));
                    if (pos.x <= 0 || pos.y <= 0 || pos.x >= this.world.w || pos.y >= this.world.h) {
                        return;
                    }
            
                    var angle = this.owner.rotation + this.cfg.angle * Math.PI / 180 - Math.PI / 2;
                    var disturb = this.cfg.disturbDeg * Math.PI / 180;
                    var bulletAngle = angle + (Math.random() * disturb - disturb / 2);
            
                    var bullet = new Bullet(this.world, pos, bulletAngle, this);
                    this.world.bullets[bullet.id] = bullet;
            
                    var recoil = this.cfg.recoil / this.owner.m;
                    // console.log("frame:" + this.world.frame + ", recoil:" + recoil + ","  + this.owner.motion.toString());
                    this.owner.motion.addRecoil(recoil, angle);
                    // console.log("frame:" + this.world.frame + "," + this.owner.motion.toString());
                }
            }
            
            Object.defineProperties(Weapon.prototype, {
                x: {
                    get: function() { return this.sprite.x; },
                    set: function(v) { this.sprite.x = v; }
                },
                y: {
                    get: function() { return this.sprite.y; },
                    set: function(v) { this.sprite.y = v; }
                },
                rotation: {
                    get: function() { return this.sprite.rotation; },
                    set: function(r) { this.sprite.rotation = r; }
                },
            });
            
            module.exports = Weapon;
            
        });
        </script>
        <script>
        require.register("./modules/world", function(module, exports, require) {
            var Config = require("../modules/config");
            var Obstacle = require("../modules/obstacle");
            var Player = require("../modules/player")
            var Tank = require("../modules/tank");
            var Util = require("../modules/util");
            
            function getWorldBackground(world)
            {
                var cfg = Config.world;
                var graphics = new PIXI.Graphics();
            
                // background spawn region
                graphics.beginFill(cfg.obstacleSpawn.color);
                graphics.drawRect(world.spawnRegion.x, world.spawnRegion.y,
                    world.spawnRegion.w, world.spawnRegion.h);
                graphics.endFill();
            
                // background grids
                graphics.lineStyle(cfg.view.grid.edge, cfg.view.grid.color);
                for (var x = cfg.view.grid.size; x < cfg.map.w; x += cfg.view.grid.size) {
                    graphics.moveTo(x, 0);
                    graphics.lineTo(x, cfg.map.h);
                }
                for (var y = cfg.view.grid.size; y < cfg.map.h; y += cfg.view.grid.size) {
                    graphics.moveTo(0, y);
                    graphics.lineTo(cfg.map.w, y);
                }
            
                return graphics;
            }
            
            function World()
            {
                this.frame = 0;
                this.cfg = Config.world;
            
                this.w = this.cfg.map.w;
                this.h = this.cfg.map.h;
            
                this.spawnRegion = {}
                this.spawnRegion.x = this.cfg.map.w * (1 - this.cfg.obstacleSpawn.wRatio) / 2;
                this.spawnRegion.w = this.cfg.map.w * this.cfg.obstacleSpawn.wRatio;
                this.spawnRegion.y = this.cfg.map.h * (1 - this.cfg.obstacleSpawn.hRatio) / 2;
                this.spawnRegion.h = this.cfg.map.h * this.cfg.obstacleSpawn.hRatio;
            
                this.gridSize = this.cfg.map.grid.size;
                this.gridW = Math.floor(this.w / this.gridSize) + 1;
                this.gridH = Math.floor(this.h / this.gridSize) + 1;
                this.grids = [];
                for (var i = 0; i < this.gridH; ++ i) {
                    for (var j = 0; j < this.gridW; ++ j) {
                        this.grids.push({});
                    }
                }
            
                var dateTime = new Date();
                this.time = dateTime.getTime();
            
                this.stage = new PIXI.Container();
            
                this.view = new PIXI.Container();
                this.view.addChild(getWorldBackground(this));
                this.stage.addChild(this.view);
            
                this.ui = new PIXI.Container();
                this.stage.addChild(this.ui);
            
                this.renderer = new PIXI.CanvasRenderer(this.cfg.view.w, this.cfg.view.h, {
                        backgroundColor: this.cfg.map.color,
                        antialias: true,
                        autoResize: true,
                    });
                document.body.appendChild(this.renderer.view);
            
                this.bullets = {};
                this.obstacles = {};
                this.obstacleCount = 0;
                this.tanks = {};
                var idx = 0;
                for (var i in Config.tanks) {
                    var tank = new Tank(this, i, { x: this.w / 2 + idx * 200, y: this.h / 2 + idx * 200, });
                    tank.autoFire = true;
                    this.tanks[tank.id] = tank;
                    ++ idx;
                }
            
                this.player = new Player(this);
                this.player.addControl();
            
                this.dieSprites = [];
            
                this.removeUnits = [];
            
                this.gameend = false;
            }
            
            World.prototype = {};
            World.prototype.constructor = World;
            
            World.prototype.updateCamera = function()
            {
                var x = this.player.x;
                var y = this.player.y;
                var viewCenterX = this.cfg.view.w / 2;
                var viewCenterY = this.cfg.view.h / 2;
                x = Util.clamp(x, viewCenterX, this.w - viewCenterX);
                y = Util.clamp(y, viewCenterY, this.h - viewCenterY);
                this.view.x = viewCenterX - x;
                this.view.y = viewCenterY - y;
            }
            
            World.prototype.updateTanks = function()
            {
                for (var i in this.tanks) {
                    var tank = this.tanks[i];
                    var oldx = tank.x;
                    var oldy = tank.y;
                    tank.update();
                    this.updateUnitGrid(tank, { x: oldx, y: oldy });
                }
            }
            
            World.prototype.updatePlayers = function()
            {
                this.player.update();
            }
            
            World.prototype.updateObstacles = function()
            {
                if (this.obstacleCount < this.cfg.obstacleSpawn.maxCount) {
                    var cfgs = [
                        Config.obstacles.small,
                        Config.obstacles.middle,
                        Config.obstacles.large
                    ];
                    var cfg = cfgs[Math.floor((Math.random() * cfgs.length))];
                    var obstacle = new Obstacle(this, cfg, {
                        x: Util.randomBetween(this.spawnRegion.x, this.spawnRegion.x + this.spawnRegion.w),
                        y: Util.randomBetween(this.spawnRegion.y, this.spawnRegion.y + this.spawnRegion.h),
                    });
                    this.obstacles[obstacle.id] = obstacle;
                    this.obstacleCount ++;
                }
            
                for (var i in this.obstacles) {
                    var obstacle = this.obstacles[i];
                    var oldx = obstacle.x;
                    var oldy = obstacle.y;
                    obstacle.update();
                    this.updateUnitGrid(obstacle, { x: oldx, y: oldy });
                }
            }
            
            World.prototype.updateBullets = function()
            {
                for (var i in this.bullets) {
                    var bullet = this.bullets[i];
                    if (bullet.outOfDate() || bullet.outOfBounds()) {
                        bullet.die();
                    } else {
                        var oldx = bullet.x;
                        var oldy = bullet.y;
                        bullet.update();
                        this.updateUnitGrid(bullet, { x: oldx, y: oldy });
                    }
                }
            }
            
            World.prototype.getUnitsIn9Grids = function(x, y)
            {
                var targets = [];
                var idxs = [
                    (y - 1) * this.gridW + x - 1,
                    (y - 1) * this.gridW + x,
                    (y - 1) * this.gridW + x + 1,
                    y * this.gridW + x - 1,
                    y * this.gridW + x,
                    y * this.gridW + x + 1,
                    (y + 1) * this.gridW + x - 1,
                    (y + 1) * this.gridW + x,
                    (y + 1) * this.gridW + x + 1,
                ];
            
                var x1 = (x >= 1);
                var x2 = (x < this.gridW - 1);
            
                var y1 = (y >= 1);
                var y2 = (y < this.gridH - 1);
            
                if (y1 && x1) {
                    var g = this.grids[idxs[0]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (y1) {
                    var g = this.grids[idxs[1]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (y1 && x2) {
                    var g = this.grids[idxs[2]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (x1) {
                    var g = this.grids[idxs[3]];
                    for (var i in g) { targets.push(g[i]); }
                }
                {
                    var g = this.grids[idxs[4]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (x2) {
                    var g = this.grids[idxs[5]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (y2 && x1) {
                    var g = this.grids[idxs[6]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (y2) {
                    var g = this.grids[idxs[7]];
                    for (var i in g) { targets.push(g[i]); }
                }
                if (y2 && x2) {
                    var g = this.grids[idxs[8]];
                    for (var i in g) { targets.push(g[i]); }
                }
                return targets;
            }
            
            World.prototype.needCheckCollision = function(unit, target)
            {
                var u1 = (unit.owner == null ? unit : unit.owner);
                var u2 = (target.owner == null ? target : target.owner);
                return u1 != u2;
            }
            
            World.prototype.elasticCollide = function(unit1, unit2)
            {
                // Elastic collision
                // m1, v10
                // m2, v20
                // v1 = [(m1-m2)v10 + 2m2v20] / (m1+m2)
                // v2 = [(m2-m1)v20 + 2m1v10] / (m1+m2)
            
                var v10 = new Victor(unit1.motion.vx, unit1.motion.vy);
                var v20 = new Victor(unit2.motion.vx, unit2.motion.vy);
            
                var v1x = ((unit1.m - unit2.m) * v10.x + 2 * unit2.m * v20.x) / (unit1.m + unit2.m);
                var v1y = ((unit1.m - unit2.m) * v10.y + 2 * unit2.m * v20.y) / (unit1.m + unit2.m);
                unit1.motion.ev.x += v1x;
                unit1.motion.ev.y += v1y;
            
                var v2x = ((unit2.m - unit1.m) * v20.x + 2 * unit1.m * v10.x) / (unit1.m + unit2.m);
                var v2y = ((unit2.m - unit1.m) * v20.y + 2 * unit1.m * v10.y) / (unit1.m + unit2.m);
                unit2.motion.ev.x += v2x;
                unit2.motion.ev.y += v2y;
            }
            
            World.prototype.simpleCollide = function(unit1, unit2, distRatio)
            {
                var dir = new Victor(unit1.x - unit2.x, unit1.y - unit2.y);
                dir.norm();
                var v1 = unit1.motion.v;
                var v2 = unit2.motion.v;
                var spring = this.cfg.springVelocityBase + (1.0 - distRatio) * this.cfg.springVelocityAdd;
                // console.log(unit1.motion.toString());
                // console.log(unit2.motion.toString());
                // console.log("spring=" + spring + ", m1=" + unit1.m + ", m2=" + unit2.m);
                unit1.motion.ev.x += (v2 + spring) * dir.x * unit2.m / unit1.m;
                unit1.motion.ev.y += (v2 + spring) * dir.y * unit2.m / unit1.m;
                unit2.motion.ev.x -= (v1 + spring) * dir.x * unit1.m / unit2.m;
                unit2.motion.ev.y -= (v1 + spring) * dir.y * unit1.m / unit2.m;
                // console.log(unit1.motion.toString());
                // console.log(unit2.motion.toString());
            }
            
            World.prototype.collide = function(unit1, unit2, distRatio)
            {
                this.simpleCollide(unit1, unit2, distRatio);
                unit1.takeDamageByUnit(unit2);
                unit2.takeDamageByUnit(unit1);
            }
            
            World.prototype.updateCollision = function()
            {
                for (var x = 0; x < this.gridW; ++ x) {
                    for (var y = 0; y < this.gridH; ++ y) {
            
                        var idx = y * this.gridW + x;
                        for (var i in this.grids[idx]) {
                            var unit = this.grids[idx][i];
            
                            // avoid multi-collision
                            if (unit.collideTime != null) {
                                if (this.time - unit.collideTime < this.cfg.unitCollideCheckMS) {
                                    continue;
                                }
                            }
            
                            // check collision with targets
                            var targets = this.getUnitsIn9Grids(x, y);
                            for (var j in targets) {
                                var target = targets[j];
                                if (unit == target) {
                                    continue;
                                }
                                if (this.needCheckCollision(unit, target) == false) {
                                    continue;
                                }
                                if (target.collideCheckFrame == this.frame) {
                                    continue;
                                }
                                var distX = unit.x - target.x;
                                var distY = unit.y - target.y;
                                var distR = unit.radius + target.radius;
                                var dist2 = distX * distX + distY * distY;
                                if (dist2 < distR * distR) {
                                    unit.collideTime = this.time;
                                    target.collideTime = this.time;
                                    this.collide(unit, target, dist2 / (distR * distR));
                                }
                            }
                            unit.collideCheckFrame = this.frame;
                        }
                    }
                }
            }
            
            World.prototype.updateDieAnimations = function()
            {
                var cfg = Config.dieAnimation;
                for (var i in this.dieSprites) {
                    var sprite = this.dieSprites[i];
                    if (sprite.alpha > cfg.alphaStart) {
                        sprite.alpha = cfg.alphaStart;
                    } else {
                        sprite.alpha -= cfg.alphaDecrease;;
                    }
                    sprite.scale.x += cfg.scaleIncrease;
                    sprite.scale.y += cfg.scaleIncrease;
                    if (sprite.alpha < cfg.alphaEnd) {
                        if (sprite.parent) {
                            sprite.parent.removeChild(sprite);
                        }
                        this.dieSprites.splice(i, 1);
                        delete sprite;
                    }
                }
            }
            
            World.prototype.updateLogic = function()
            {
                var dateTime = new Date();
                var ms = dateTime.getTime();
                while (ms > this.time + this.cfg.updateMS) {
                    this.time += this.cfg.updateMS;
                    this.frame ++;
                    this.updatePlayers();
                    this.updateTanks();
                    this.updateObstacles();
                    this.updateBullets();
                    this.updateCollision();
                    this.updateDieAnimations();
                }
            }
            
            World.prototype.updateUnitGrid = function(unit, oldPos)
            {
                if (oldPos.x == unit.x && oldPos.y == unit.y) {
                    return;
                }
            
                var ogx = Math.floor(oldPos.x / this.gridSize);
                var ogy = Math.floor(oldPos.y / this.gridSize);
                var oidx = ogy * this.gridW + ogx;
            
                var gx = Math.floor(unit.x / this.gridSize);
                var gy = Math.floor(unit.y / this.gridSize);
                var idx = gy * this.gridW + gx;
            
                if (idx != oidx) {
                    delete this.grids[oidx][unit.id];
                }
                this.grids[idx][unit.id] = unit;
            }
            
            World.prototype.removeUnitFromGrid = function(unit)
            {
                var gx = Math.floor(unit.x / this.gridSize);
                var gy = Math.floor(unit.y / this.gridSize);
                var idx = gy * this.gridW + gx;
                delete this.grids[idx][unit.id];
            }
            
            World.prototype.addUnitToGrid = function(unit)
            {
                var gx = Math.floor(unit.x / this.gridSize);
                var gy = Math.floor(unit.y / this.gridSize);
                var idx = gy * this.gridW + gx;
                this.grids[idx][unit.id] = unit;
            }
            
            World.prototype.update = function()
            {
                this.updateLogic();
                this.updateCamera();
                this.renderer.render(this.stage);
            }
            
            module.exports = World;
            
        });
        </script>
        <script>
        require.register("./modules/util", function(module, exports, require) {
            var Util = {
            
                id: 0,
            
                unitType: {
                    tank: 1,
                    weapon: 2,
                    bullet: 3,
                    obstacle: 4
                },
            
                clamp: function(value, min, max) {
                    if (value > max) {
                        value = max;
                    }
                    if (value < min) {
                        value = min;
                    }
                    return value;
                },
            
                clampPosition: function(pos, minx, maxx, miny, maxy) {
                    if (pos.x > maxx) {
                        pos.x = maxx;
                    }
                    if (pos.x < minx) {
                        pos.x = minx;
                    }
                    if (pos.y > maxy) {
                        pos.y = maxy;
                    }
                    if (pos.y < miny) {
                        pos.y = miny;
                    }
                },
            
                randomBetween: function(min, max) {
                    return Math.random() * (max - min) + min;
                },
            
                getId: function() {
                    return ++ this.id;
                },
            };
            
            module.exports = Util;
        });
        </script>

        <script src="./main.js"></script>
    </body>
</html>
